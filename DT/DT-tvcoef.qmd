---
title: "Utilisation de modèles de régression à coefficients variant dans le temps pour la prévision conjoncturelle"
format: 
  pdf:
    include-in-header: template/preambule.tex
  html: 
    self-contained: true
    include-before-body: template/preambule.html
    css: [template/style.css]
execute:
  freeze: true 
toc: true
number-sections: true
bibliography: biblio.bib
biblio-style: authoryear
author:
  - name: Alain Quartier-la-Tente 
    affiliation: Insee
    affiliation-url: https://www.insee.fr/fr/
citation:  
  type: article-journal
  container-title: "Document de travail méthodologique Insee"
  issued: 2024
  url: https://github.com/InseeFrLab/DT-tvcoef
  pdf-url: https://www.insee.fr/fr/statistiques/7759578
  # key: inseeDTM2024XX
# license:
#   text: > 
#     Copyright (c) 2024 Alain Quartier-la-Tente, INSEE
# 
#     Permission is hereby granted, free of charge, to any person obtaining a copy
#     of this software and associated documentation files (the "Software"), to deal
#     in the Software without restriction, including without limitation the rights
#     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#     copies of the Software, and to permit persons to whom the Software is
#     furnished to do so, subject to the following conditions:
#     
#     The above copyright notice and this permission notice shall be included in all
#     copies or substantial portions of the Software.
#     
#     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
#     SOFTWARE.
#   type: MIT
lang: fr
language:
 title-block-author-single: Auteur
---

```{r}
#| include: false
library(tvCoef)
library(dynlm)
library(strucchange)
library(tvReg)
library(ggplot2)
library(patchwork)
library(forecast)
coef2plot <- function(x, linetype = 1, start = NULL, end = NULL){
  noms_mod <- names(x)
  linetype <- rep(linetype, length(x))
  x <- lapply(x, window, start = start, end = end, extend =TRUE)
  plot_i <- function(x, col){
    p <- autoplot(x[[1]][,col], series = noms_mod[1], linetype=linetype[1]) + 
      labs(y = NULL, x = NULL, title = colnames(x[[1]])[col])
    
    for (i in seq_len(length(x)-1)+1) {
      p <- p + autolayer(x[[i]][,col], series = noms_mod[i], linetype=linetype[i])
    }
    p +
      theme_bw() + 
      theme(legend.title=element_blank())+
    scale_color_grey(breaks = noms_mod)
  }
  (plot_i(x, 1) + plot_i(x, 2) / plot_i(x, 3)) + 
    plot_layout(guides = 'collect') 
}
```


<!-- \thispagestyle{fancy} -->

::: {.content-visible when-format="html"}
Remerciements :
:::

# Résumé {-}

:::: {.abstract}
Dans la statistique publique, de nombreux modèles de prévision s’appuient sur des régressions linéaires. En effet, les producteurs appliquent des modèles RegARIMA pour la correction des effets de calendrier. Pour la prévision des grands agrégats macroéconomiques, le département de la conjoncture de l’Insee utilise notamment des étalonnages et le modèle Mésange s’appuie sur des modèles à correction d’erreur pour modéliser les comportements macroéconomiques. Ces méthodes fournissent généralement de bons résultats et ont l’avantage d’être facilement interprétables. Cependant, ils supposent que les relations entre les variables sont fixes dans le temps : cette hypothèse peut avoir du sens sur courte période mais n’est généralement plus vérifiée lorsque les modèles sont estimés sur longue période, ce qui conduit à des modèles sous-optimaux.
L’objectif de cette étude est d’étudier différentes méthodes d’estimation de coefficients variant dans le temps dans le cadre de la prévision conjoncturelle. Ces méthodes se regroupent en trois catégories : 

- les modèles de régression par morceaux

- les régressions locales

- les modèles espace-état

Pour simplifier l’implémentation de ces méthodes, ainsi que leur comparaison, un package R a également été développé lors de cette étude. 
Les premiers résultats montrent que, lorsque l’hypothèse de constance des coefficients n’est pas vérifiée, l’utilisation de ces modèles (notamment la modélisation espace-état) permet de réduire les erreurs de prévision (en temps réel et dans l’échantillon). De plus, ils ont l’avantage d’être plus facilement interprétables que des méthodes de machine learning, puisqu’ils s’appuient sur des modèles de régression linéaire.
L’atelier montrera comment mettre en application ces différentes méthodes, interpréter et comparer les résultats.


Mots clés : séries temporelles, tendance-cycle, désaisonnalisation, points de retournement.
::::

:::: {.abstract}


Keywords: time series, trend-cycle, seasonal adjustment, turning points.
::::

JEL Classification: E32, E37.

\newpage


# Introduction

Sur longue période, les institutions, les normes de sociétés ainsi que les comportements des agents économiques évoluent, induisant des changements dans la dynamique des séries économiques étudiées.

De nombreux modèles de l'Insee sont basés sur des régressions linéaires (CJO, prévisions, calage...) qui supposent que les relations entre les variables sont fixes dans le temps.


Hypothèse vraie sur le court-terme mais généralement fausse sur le long-terme ou en présence de changements structurels (changement de nomenclature, de définition, COVID...)


Objectifs : 

- étudier des méthodes qui permettent de relâcher cette contrainte ;

- proposer une façon simple d'implémenter et de comparer ces méthodes (package {{< fa brands r-project >}} `tvCoef`)

@JMS2018 et @eurostat2015guidelines


# Modélisation générale et tests

Dans cet article, nous nous placerons dans le cadre de la régression linéaire avec des variables à une dimension.
À chaque date $t$, la variable $y_t$ (e.g. : taux de croissance du PIB) est expliquée par une combinaison linéaire de $p$ variables explicatives, $x_{0,t},\dots,x_{p,t}$ (soldes d'opinion, indices de production industrielle, indicatrices, etc.)  :
$$
y_t=\alpha_{0}+\alpha_{1} x_{1,t}+\dots+\alpha_{p} x_{p,t} +\varepsilon_t 
$$
où $\varepsilon_t$ représente l'erreur d'approximation.
En notant ${\bf X}_t=\transp{\begin{pmatrix}1 & x_{1,t} &\cdots & x_{p,t} \end{pmatrix}}$ et 
${\bf \alpha}=\transp{\begin{pmatrix}\alpha_0 & \alpha_1 &\cdots & \alpha_p \end{pmatrix}}$, cela s'écrit matriciellement\ :
$$
y_t=\transp{\bf X_t} \bf\alpha +\varepsilon_t.
$$

Dans le cadre de la régression linéaire, les coefficients $\bf\alpha$ sont supposés constants dans le temps et estimés en utilisant l'ensemble des données.
Cela suppose donc que la relation économique entre les différentes variables est stable dans le temps.
Même si cette hypothèse est généralement vraie sur le court-terme, elle peut être invalidée sur le long-terme du fait de changements structurels (mesures économiques, crises, changement de nomenclature, etc.)
L'objectif de cet article est d'étudier différent modèles permettant de relâcher cette hypothèse de constance des coefficients.
Le modèle général s'écrit donc :
$$
y_t=\transp{\bf X_t} \bf\alpha_t  +\varepsilon_t.
$$
Pour faciliter l'utilisation des modèles ici présentés, le package {{< fa brands r-project >}} `tvCoef` [@tvcoef] a été développé pour cette étude.

Les différentes méthodes seront illustrées à travers l'exemple de la prévision du taux de croissance trimestriel du PIB à partir du climat des affaires France publié par l'Insee.
Ces séries sont disponibles sous {{< fa brands r-project >}} dans la base de donnée `tvCoef::gdp` :

- `growth_gdp` correspond au taux de croissance trimestriel du PIB ;

- `bc_fr_m1` correspond au climat des affaires au premier mois de chaque trimestre (la valeur de 2000T1 correspond à la valeur de janvier 2000, celle de 2000T2 à celle d'avril 2000, etc.) ;

- `diff_bc_fr_m1` correspond à la différenciation trimestrielle de la variable précédente (la valeur de 2000T1 correspond à la différence du climat des affaires entre de janvier 2000 et octobre 1999).

Le modèle s'écrit donc :
$$
\% PIB_t=\alpha_0 + \alpha_1\times climat\_fr_t^{m_1} + \alpha_2\times \Delta climat\_fr_t^{m_1}+\varepsilon_t.
$$

Il est estimé en utilisant les données entre les années 1980 et 2019.
Sous {{< fa brands r-project >}}, ce modèle peut être estimé en utilisant la fonction `stats::lm()`.
Toutefois, nous recommandons d'utiliser le package `dynlm` [@dynlm] qui offre une plus grande flexibilité dans la définition des modèles et de conserver le format série temporelle dans les fonctions de `tvCoef`.

```{r}
#| warning: false
#| message: false
library(tvCoef)
library(dynlm)
reg_lin <- dynlm(
  formula = growth_gdp ~ bc_fr_m1 + diff_bc_fr_m1,
  data = window(gdp, start = 1980, end = c(2019,4))
)
# # Equivalent à :
# reg_lin <- dynlm(
#   formula = growth_gdp ~ bc_fr_m1 + diff(bc_fr_m1, 1),
#   # Date de début changée car on perd une donnée avec la différenciation
#   data = window(gdp, start = c(1979,4), end = c(2019,4))
# )
coefficients(reg_lin)
```

Le modèle estimé est donc :
```{r}
#| echo: false
#| output: asis
cat(sprintf("$$\\%% PIB_t=%.2f + %.2f\\times climat\\_fr_t^{m_1} + %.2f\\times \\Delta climat\\_fr_t^{m_1}+\\hat\\varepsilon_t.$$",
            coef(reg_lin)[1],
            coef(reg_lin)[2],
            coef(reg_lin)[3]))
```



## Test de rupture brutale {#sec-test-baiperron}

L'idée la plus simple pour tester s'il y a une rupture dans l'estimation des coefficients à une date $t_1$, est d'estimer deux sous-modèles avant et après cette date :
$$
\begin{cases}
\forall t \leq t_1 :\quad \% PIB_t = \alpha_0' + \alpha_1' climat\_fr_t + \alpha_2' \Delta climat\_fr_t + \varepsilon_t' \\
\forall t > t_1 :\quad \% PIB_t = \alpha_0'' + \alpha_1'' climat\_fr_t + \alpha_2'' \Delta climat\_fr_t + \varepsilon_t''
\end{cases}.
$$
Il ne reste ensuite qu'à tester si les coefficients estimés entre les deux sous-périodes sont égaux\ : $\alpha_0' = \alpha_0''$, $\alpha_1' = \alpha_1''$ et $\alpha_2' = \alpha_2''.$
L'hypothèse alternative et qu'au moins un des coefficients est différent entre les deux sous-périodes.
C'est le principe du test de @chowtest.

L'inconvénient est que cela suppose d'avoir un a priori sur la date de la rupture à tester.
Pour palier à ce problème, @bai2003computation ont proposé un algorithme efficace afin de chercher la présence de ruptures multiples dans des modèles de régression linéaire.
Cet algorithme a été implémenté sous {{< fa brands r-project >}} dans le package `strucchange` @strucchangeBP.
La fonction `strucchange::breakpoints()` permet de chercher les ruptures et la fonction `strucchange::breakdates()` d'extraire facilement les dates associées.
Le package `tvCoef` implémente une méthode `breakpoints.lm()` afin de pouvoir directement appliquer cette fonction aux régressions linéaires estimées :

```{r}
library(strucchange)
bp <- breakpoints(reg_lin)
breakdates(bp)
```
Une seule rupture est détectée au `{r} format(zoo::as.yearqtr(breakdates(bp)), "%YT%q")`.
Un intervalle de confiance autour de la date détectée peut être calculée peut en utilisant la fonction `confint()` :
```{r}
breakdates(confint(bp))
```
L'incertitude autour de la date détectée est grande ! 
Il y a 95 % de chance que la rupture soit comprise entre `{r} format(zoo::as.yearqtr(breakdates(confint(bp))[1]), "%YT%q")` et `{r} format(zoo::as.yearqtr(breakdates(confint(bp))[3]), "%YT%q")`.

Cet algorithme est très simple à utiliser mais possède plusieurs inconvénients :

- L'implémentation sous {{< fa brands r-project >}} de l'algorithme de Bai et Perron ne permet pas de chercher des ruptures sur un sous-ensemble de variables : on ne cherche des ruptures que sur l'ensemble du modèle.
Par exemple, on ne peut pas tester $\alpha_2' = \alpha_2''$ dans le modèle :
$$
\begin{cases}
\forall t \leq t_1 :\quad \% PIB_t = \alpha_0 + \alpha_1 climat\_fr_t + \alpha_2' \Delta climat\_fr_t + \varepsilon_t' \\
\forall t > t_1 :\quad \% PIB_t = \alpha_0 + \alpha_1 climat\_fr_t + \alpha_2'' \Delta climat\_fr_t + \varepsilon_t''
\end{cases}.
$$
Une solution simple est d'effectuer une première régression sur l'ensemble des données afin d'estimer $\alpha_0$ et $\alpha_1$ et d'ensuite appliquer la procédure de Bai et Perron sur le modèle\ :
$$
\begin{cases}
\forall t \leq t_1 :\quad (\% PIB - \hat\alpha_0-\hat \alpha_1 climat\_fr)_t = \alpha_2' \Delta climat\_fr_t + \varepsilon_t' \\
\forall t > t_1 :\quad (\% PIB - \hat\alpha_0-\hat \alpha_1 climat\_fr)_t = \alpha_2'' \Delta climat\_fr_t + \varepsilon_t''
\end{cases}.
$$

- Il y a une instabilité sur le choix de la date et il suppose que la rupture est brutale à partir d'une certaine date.
Si la rupture est brutale, le statisticien doit pouvoir expliquer son origine (changement de nomenclature, de champ dans les données, crise...) et a déjà un a priori sur la date de rupture.
Si l'on n'a aucune information sur la présence d'une rupture, on peut raisonnablement penser que celle-ci n'est pas brutale mais que la relation entre les variables a évolué de manière progressive dans le temps.


## Test de constance des coefficients {#sec-hansen-test}

Alors que l'algorithme de Bai et Perron cherche une date spécifique où il y aurait une rupture dans les modèles,
@hansen1992testing propose une procédure permettant de tester uniquement si les coefficients sont constants ou non sans hypothèse sur la forme de la rupture (brutale ou non) et sur la date de la rupture.

En repartant de la modélisation générale de la régression linéaire :
\begin{align*}
y_t&=\alpha_{0}x_{0,t}+\alpha_{1} x_{1,t}+\dots+\alpha_{p} x_{p,t} +\varepsilon_t  \\
&= \transp{\bf X_t} \bf\alpha  +\varepsilon_t\\
\E{\varepsilon_t|x_t}&=0 \text{ (exogénéité stricte)} \\
\E{\varepsilon_t^2}&=\sigma_t^2\text{ et } \underset{n\to\infty}{\lim}\frac{1}{n}\sum_{t=1}^n\sigma_t^2=\sigma.
\end{align*}
On suppose également que toutes les variables sont faiblement dépendantes (cas général de la régression linéaire).
Les variables ne doivent donc pas contenir de tendance déterministe ou stochastique (comme des racines unitaires).

Le test consiste à tester si l'ensemble des paramètres $(\alpha,\sigma^2)$ sont constants.
L'hypothèse alternative est qu'au moins un paramètre suit une martingale.

Notons $\hat \varepsilon_t =y_t- \transp{\bf X_t} \hat{\bf\alpha} $ et
$$
f_{i,t} = \begin{cases}
x_{i,t}\hat \varepsilon_t &\text{ si }i\leq p\\
\hat \varepsilon_t^2 - \hat \sigma^2&\text{ si }i=p+1
\end{cases}
\text{ et }S_{i,t} = \sum_{j=1}^tf_{i,j}\qquad(\text{N.B : }S_{i,n}=0)
$$ 
D'après les conditions de premier ordre $S_{i,n}=0.$

Le test individuel de constance du coefficient du paramètre $i$ est :
$$
L_i=\frac{1}{nV_i}\sum_{t=1}^nS_{i,t}^2\qquad
\text{avec }V_i=\sum_{t=1}^nf_{i,t}^2.
$$ 

Notons :
$$
\bf f_t= \begin{pmatrix}
f_{1,t} \\ \vdots \\ f_{p+1,t}
\end{pmatrix} \text{ et }
\bf S_t= \begin{pmatrix}
S_{1,t} \\ \vdots \\ S_{p+1,t}
\end{pmatrix}.
$$
Le test joint de constance de l'ensemble des paramètres est :
$$
L_c = \frac{1}{n}
\sum_{t=1}^n\transp{\bf S_t}\bf V^{-1}\bf S_t
\text{ avec }\bf V=\sum_{t=1}^n\bf f_{t}\transp{\bf f_{t}}.
$$
Il s'adapte facilement à un test de joint de constance d'un sous-ensemble de paramètres en utilisant des sous-vecteurs de $\bf f_t$ et $\bf S_t.$
Toutefois, si modèle contient des indicatrices alors le test joint ne pourra pas être calcule (la matrice $\bf V$ ne sera pas inversible).

Sous l'hypothèse nulle de constance des paramètres, les $S_{i,t}$ devraient tendre vers 0 (à la manière d'une marche aléatoire contrainte) : les statistiques de test $L_i$ et $L_c$ devraient donc être petites.
Sous l'hypothèse alternative d'instabilité des paramètres, la somme cumulée des $S_{i,t}$ devrait ne pas être de moyenne nulle dans un sous-ensemble de l'échantillon et la statistique de test devrait être élevée.
L'hypothèse nulle de stabilité des coefficients est donc rejetée lorsque la statistique de test est grande.
Sous l'hypothèse nulle, la loi de distribution asymptotique est non standard, les valeurs critiques sont présentés dans la [table @tbl-hansen-table].

::: {#tbl-hansen-table}

```{r}
#| echo: false
table <- tvCoef::hansen_table
colnames(table) <- gsub("%"," %", colnames(table))
colnames(table) <- gsub(".",",", colnames(table), fixed = TRUE)
colnames(table)[1] <- "Degrés de liberté"
knitr::kable(table, format.args = list(decimal.mark = ","))
```

Source : @hansen1990lagrange.

Valeurs critiques asymptotiques pour $L_c$ en fonction du nombre de paramètres testés (1 degré de liberté pour $L_i$).
:::

Ce test est implémenté dans la fonction `tvCoef::hansen_test()`.
Par défaut, le test joint ne comprend pas le test de constance de la variance (`sigma = FALSE`).

```{r}
hansen_test(reg_lin)
```
Sur notre modèle de prévision de la croissance, le test de Hansen conclut à la non-constance des coefficients associés à la constance et au climat des affaires en niveau au seuil de 5 %.
En revanche, le coefficient associé au climat des affaires en différences serait constant (au seuil de 5 %).


Le test de Hansen peut être vu comme une extension des tests de stabilité CUSUM (*cumulative sum control chart*) et CUSUM sur les carrés (pour le test sur la variance).
Il est robuste à l'hétéroscédasticité.
En appliquant les mêmes formules au modèle "transformé", ce test est également robustes à la prise en compte de l'autocorrélation via les moindres carrés généralisés.
En revanche, ce test suppose que toutes les variables sont stationnaires : il ne peut donc directement s'appliquer sur des modèles du type modèle à correction d’erreur.
Dans ce cas, une loi asymptotique différente doit être utilisée^[
Voir par exemple @hansen1992I1.
Une implémentation sous {{< fa brands r-project >}} de ce cas est disponible sous <https://users.ssc.wisc.edu/~bhansen/progs/jbes_92.html>.
].
Si le modèle est estimé en deux étapes par la méthode de @engle1987co, le test peut en revanche s'appliquer sur la seconde estimation (estimation des paramètres de court-terme).


## Autres tests

@abs2006

# Différents modèles utilisés

Si un des tests précédents conclut à la non constance des coefficients du modèle estimé c'est qu'il est mal spécifié et donc qu'il faut utiliser une modélisation alternative qui pourrait notamment provenir d'un problème de variables omises.
Dans cet article, nous supposons que le problème de spécification provient des observations récentes et qu'il n'est pas nécessaire de faire un ajout de nouvelles variables explicatives pour le régler.
Dans certains cas, comme par exemple pour prendre en compte la crise du COVID-19, il peut être utile nécessaires d'ajouter des variables supplémentaires (e.g. : des indicatrices).

Trois méthodes sont étudiées dans cet article :

- la régression linéaire par morceaux (@sec-reg-morceaux) ;

- la régression locale (@sec-reg-locale) ;

- les modèles espace-état (@sec-ssm).

## Régression par morceaux {#sec-reg-morceaux}

La régression par morceaux est la modélisation la plus simple : elle consiste à estimer le modèle sur un sous-ensemble des données.
La modélisation est similaire à celle de la procédure de Bai et Perron puisque cette dernière donne directement les "morceaux" : entre les dates de ruptures.

Par exemple, pour le modèle de prévision de la croissance, deux régressions seraient estimés en utilisant les données avant et après  `{r} format(zoo::as.yearqtr(breakdates(bp)), "%YT%q")`.

Deux méthodes d'estimations sont possibles :

1. Une régression en une étape est faite en doublant découpant les régresseurs en fonction de la date de rupture (fonction `tvCoef::piece_reg()`) :
```{r}
#| echo: false
#| output: asis
date_rupture <- format(zoo::as.yearqtr(breakdates(bp)), "%YT%q")
cat(
  sprintf("
\\begin{align*}
\\%% PIB_t &= \\alpha_0\\1_{t\\leq %s} + \\alpha_1 climat\\_fr_t\\1_{t\\leq %s} + \\alpha_2 \\Delta climat\\_fr_t\\1_{t\\leq %s} + \\\\
&\\phantom{=} \\alpha_0'\\1_{t > %s} + \\alpha_1' climat\\_fr_t\\1_{t > %s} + \\alpha_2' \\Delta climat\\_fr_t\\1_{t > %s} + \\varepsilon_t
\\end{align*}
          ",date_rupture,date_rupture,date_rupture,date_rupture,date_rupture,date_rupture
  )
)
```

2. En effectuant deux régressions linéaires distinctes (fonction `tvCoef::bp_lm()`) :
```{r}
#| echo: false
#| output: asis
cat(
  sprintf("$$
\\begin{cases}
\\forall t \\leq %s :\\quad \\%% PIB_t = \\alpha_0 + \\alpha_1 climat\\_fr_t + \\alpha_2 \\Delta climat\\_fr_t + \\varepsilon_t \\\\
\\forall t > %s :\\quad \\%% PIB_t = \\alpha_0' + \\alpha_1' climat\\_fr_t + \\alpha_2' \\Delta climat\\_fr_t + \\varepsilon_t'
\\end{cases}.
$$          ",date_rupture,date_rupture
  )
)
```
Dans les deux cas les coefficients estimés sont les mêmes mais les écarts-types seront en général différents.
En effet, dans la première modélisation on suppose que la variance du résidu est constante dans les deux sous-périodes alors que dans la seconde on autorise la variance à évoluer dans le temps.

Dans la majorité des cas, nous suggérons de privilégier la première modélisation car elle offre plus de flexibilité, notamment pour fixer les coefficients de certaines variables.

Dans notre exemple, les coefficients associés à la constante et au climat des affaires en niveau sont proches avant et après la rupture, ce qui est cohérent avec le résultat du test de Hansen (section [-@sec-hansen-test]) :
```{r}
reg_morc <- piece_reg(reg_lin)
coef(reg_morc$model)
```
Cette égalité peut être testée en utilisant un test de Fisher, par exemple avec la fonction `car::linearHypothesis()`.
Dans notre exemple, on ne rejette pas l'hypothèse nulle d'égalité des coefficients de la constante et du climat des affaires en niveau avant et après la rupture, modèle peut donc être simplifié.
Par ailleurs, on rejette l'hypothèse nulle d'égalité du coefficient associé au climat des affaires en différence : la prise en compte de la rupture est donc justifiée.
Toutefois, nous conseillons de toujours considérer que la constante varie dans le temps, même lorsque que ce n'est statistiquement pas significatif : cela permet de s'assurer que le modèle ne sera pas biaisé par des résidus qui ne seraient pas de moyenne nulle.
```{r}
car::linearHypothesis(
  reg_morc$model,
  c("`(Intercept)_2000.25` = `(Intercept)_2019.75`",
    "bc_fr_m1_2000.25 = bc_fr_m1_2019.75"),
  test = "F")
reg_morc <- piece_reg(reg_lin, fixed_var = 2)
car::linearHypothesis(
  reg_morc$model,
  c("diff_bc_fr_m1_2000.25 = diff_bc_fr_m1_2019.75"),
  test = "F")
coef(reg_morc$model)
```

La qualité prédictive du nouveau modèle peut s'apprécier de plusieurs façons, les plus classiques étant la minimisation du critère d'information d'Akaike (AIC et fonction `AIC()`) ou la minimisation des erreurs de prévisions en temps réel (fonction `tvCoef::oos_prev()`).
Pour le calcul des erreurs de prévisions en temps réel, la méthodologie retenue consiste à calculer pour chaque date $t$ la prévision obtenue à la date $t+1$ en estimant le modèle à partir des observations disponibles jusqu'à la date $t$ uniquement.
Avec cette méthode, appelée le *leave-one-out cross-validation*, on ne s'intéresse donc qu'à la qualité de prévision à l'horizon d'un trimestre (ce qui est le cas d'utilisation pour les modèles étudiés).
Par ailleurs, minimiser l'AIC est asymptotiquement équivalent à minimiser ces erreurs de prévisions en temps réel (voir @AIC).

Sur notre exemple, la régression linéaire par morceaux permet de minimiser ces deux critères :
```{r}
# AIC minimisé :
AIC(reg_morc$model) < AIC(reg_lin)
oos_pr <- oos_prev(reg_morc)
oos_lm <- oos_prev(reg_lin)
res <- ts.union(oos_pr$residuals, oos_lm$residuals)
# Les deux modèles étant équivalents avant la rupture,
# on n'étudie les prévisions qu'après celle-ci
res <- window(res, start = 2003)  
# Erreurs de prévisions en temps réel minimisées
apply(res, 2, rmse)
```

La [figure -@fig-prev-piecereg] montre les prévisions en temps réel des deux modèles étudiés.
Autour de la date de rupture, la régression linéaire par morceaux produit des prévisions peu réalistes : cela s'explique par le fait que très peu d'observations sont utilisées pour estimer les coefficients associés aux régresseurs après la rupture, les estimateurs sont donc peu précis (grande variance).
Pour les analyses en temps réel, il faut donc faire attention aux valeurs prédites autour de la rupture !


```{r}
#| echo: false
#| fig-cap: Prévision du PIB à partir d'un modèle de régression linéaire et d'un modèle de régression linéaire par morceaux.
#| label: fig-prev-piecereg
prev <- ts.intersect(gdp[,"growth_gdp"], oos_lm$forecast, oos_pr$forecast)
colnames(prev) <- c("% PIB", "Reg. lin.",
                    "Reg. par morceaux")
forecast::autoplot(prev[,1],
                   series = colnames(prev) [1]) +
  forecast::autolayer(prev[,-1], linetype = 3,
                      series = colnames(prev)[-1]) +
  theme_bw() + 
  labs(x = NULL, y = "%") +
  theme(
    legend.background = element_rect(fill = alpha('gray99', 0.4),
                                     colour = "gray80", linetype = "solid"),
    legend.justification = c(0,0),
    legend.position.inside = c(0,0),
    legend.key = element_blank(),
    legend.title = element_blank()
  )
```

Comme indiqué dans la [section -@sec-test-baiperron], l'inconvénient de cette méthode provient du choix de la date de rupture lorsque celle-ci n'est pas imposée par l'utilisateur.
La [figure -@fig-temps-reel-bp] montre les dates de la rupture détectée par la procédure de Bai et Perron en fonction de la date de fin de fin d'estimation du modèle de régression linéaire : aucune rupture n'est détectée avant 2009 ou lorsque le modèle est estimé en utilisant des données jusqu'en 2013T2-2015T3.
En fonction de la date de fin d'estimation, la rupture détectée automatiquement peut tout aussi bien être en 2000 qu'en 2004 ou 2006.
Même s'il est possible que cela n'ait que très peu d'effet sur les prévisions estimées en fin de période, l'interprétation faite du modèle sera vraisemblablement différente !


```{r}
#| echo: false
#| label: fig-temps-reel-bp
#| fig-cap: Date de rupture détectée par l'algorithme de Bai et Perron en fonction de la date de fin d'estimation du modèle.
# On enlève les premières observations car pas de rupture
bp <- lapply(oos_lm$model[-(1:74)],breakpoints)
bpd <- sapply(bp, breakdates)
bpd <- bpd * sapply(bp, `[[`, "nobs")
bp_ts <- ts(time(get_data(reg_morc))[bpd], 
            end = end(oos_lm$forecast),
            frequency = frequency(oos_lm$forecast))
ggplot(data = na.omit(data.frame(x = as.numeric(time(bp_ts)),
       y = as.numeric(bp_ts))),
       aes(x = x, y = y)) +
  geom_point() +
  theme_bw() +
  coord_cartesian(xlim =c(2009,NA)) +
  scale_x_continuous(breaks = seq(2010,2020, by = 2))+
  labs(x = "Date de fin d'estimation",
       y = "Date de rupture détectée")
```





## De la régression mobile à la régression locale {#sec-reg-locale}

La régression mobile est une des méthodes empiriques les plus simples pour savoir si les coefficients évoluent dans le temps.
Celle-ci consiste à estimer des régression en utilisant un intervalle de temps fixe et à observer la courbe des coefficients estimés.
En reprenant notre exemple où les données commencent en 1980, avec une fenêtre fixe de 15 ans (par exemple), cela consiste à estimer une première régression entre 1980T1 et 1994T4, une deuxième entre 1980T2 et 1995T1... et une dernière entre 2005T1 et 2019T4.
Sous R cela peut par exemple s'estimer en utilisant la fonction `rollRegres::roll_regres()` :
```{r}
roll_regres <- rollRegres::roll_regres(
  formula = growth_gdp ~ bc_fr_m1 + diff_bc_fr_m1,
  data = window(gdp, start = 1980, end = c(2019,4)),
  width = 4 * 15
)
coef_roll_regres <- ts(roll_regres$coefs, start = 1980, frequency = 4)
```

La [figure -@fig-coef-rollreg] montre les coefficients estimés par cette régression mobile.
Seule ceux estimés sur le climat des affaires en différence montrent une rupture nette.
Elle s'observe à partir de 2009, lorsque plus de la moitié des points de la fenêtre (7,5 ans) sont estimés après la date de rupture détectée (2000T2).

::: {#fig-coef-rollreg}
```{r}
#| echo: true
coef_roll_regres <- na.omit(coef_roll_regres)
coef_pr <- coef(reg_morc)
coef_lin <- ts(matrix(coef(reg_lin), nrow = 1), 
               start = start(coef_pr),
               end = end(coef_pr),
               frequency = frequency(coef_pr))
colnames(coef_lin) <- names(coef(reg_lin))

coef2plot(
  list(
    "Reg. linéaire" = coef_lin,
    "Reg. par morceaux" = coef_pr,
    "Reg. mobile" = coef_roll_regres
  ),
  start = start(coef_roll_regres)
  )
```

Lecture : la régression mobile est estimée sur une fenêtre de 15 ans.
Les coefficients estimés en 1994T4 correspondent aux coefficients estimés entre 1980T1 et 1994T4.

Coefficients estimés par régression mobile et régression par morceaux.
:::

La régression mobile a l'avantage d'être très simple mais repose sur plusieurs paramètres qui ont ici été fixés arbitrairement dont notamment :

- La longueur de la fenêtre : elle doit être suffisamment large pour avoir des bonnes estimations mais suffisamment courte afin de permettre de prendre en compte les ruptures.

- La date à laquelle les coefficients sont associés.
Dans la fonction `rollRegres::roll_regres()` ils sont associés à la dernière date de la fenêtre : les coefficients de la date $t$ correspondent à ceux obtenus en utilisant les données jusqu'à la date $t.$
Ils auraient également pu être associés à la première date de la fenêtre ou encore à son milieu (coefficients de la date $t$ estimés en utilisant autant d'observations avant et après $t$).
Dans tous les cas une stratégie doit être adoptée afin de gérer les observations manquantes (dans notre exemple il s'agit donc d'estimer les coefficients avant 1994).

La régression locale permet, grâce à une modélisation plus poussée, de donner des solutions à ce problème.
Dans ce papier nous détaillons la modélisation utilisée dans la fonction `tvReg::tvLM()` développée par @tvReg^[
D'autres packages sont disponibles pour effectuer de la régression locale, dont par exemple `locfit` de @locfit.
Toutefois, nous avons ici privilégié le package `tvReg` du fait de sa simplicité d'utilisation et parce qu'il implémente également une fonction `tvReg::tvAR()` pour permet de prendre en compte de manière optimale les retards de la variable endogène (non étudiée dans cette étude).
].
On suppose ici que les coefficients $\bf\alpha_t$ dépendent d'une variable aléatoire $z_t$ : $\bf\alpha_t=\alpha(z_t).$
Par défaut $z_t=t/T$ avec $T$ le nombre d'observations : les coefficients dépendent donc d'une mesure normalisée du temps.
On suppose que la fonction $\alpha$ est localement constante ($\alpha(z_t)\simeq \alpha(z)$, option par défaut) ou localement linéaire  ($\alpha(z_t)\simeq \alpha(z)+\alpha'(z)(z_t-z)$), c'est-à-dire que pour toute date $t$ on a pour toute date $i$ proche de $t$ : $\alpha(z_i)\simeq\alpha(z_t)$ ou $\alpha(z_i)\simeq\alpha(z_t)+\alpha'(z_t)(z_i-z_t).$ 
Cette approximation locale est justifiée par le théorème de Taylor.

Pour chaque date $t$, le coefficient $\alpha_t=\alpha(z_t)$ est obtenu par moindre carrés pondérés.
Lorsque $\alpha$ est supposé localement constant il s'agit du système :
$$
\hat{\bf\alpha_t}=\hat{\alpha}(z_t)=\underset{\bf\theta_0}\argmin\sum_{i=1}^T\left[y_i-\transp{\bf X_i}\bf\theta_0 \right]^2K_{b_t}(z_i-z_t).
$$
Lorsque $\alpha$ est supposé localement linéaire il s'agit du système :
$$
(\hat{\alpha}(z_t), \hat{\alpha}'(z_t))=\underset{\bf \theta_0,\bf \theta_1}\argmin\sum_{i=1}^T\left[y_i-\transp{\bf X_i}\bf\theta_0 - (z_i-z_t)\transp{\bf X_i}\bf\theta_1\right]^2K_{b_t}(z_i-z_t).
$$
Avec $K_{b_t}(z_i-z_t)=\frac{1}{b_t}K\left(\frac{z_i-z_t}{b_t}\right)$ et $K(\cdot)$ une fonction de noyau.
La fonction $K$ permet de pondérer les observations : pour l'estimation du coefficient à la date $t$ on accorde généralement plus d'importance (i.e., un poids plus important) aux observations qui sont proches de $t$ qu'à celles qui sont éloignées de $t.$
C'est une fonction positive, paire et intégrable telle que $\int_{-\infty}^{+\infty}K(u) \ud u=1.$
Trois noyaux sont disponibles dans la fonction `tvReg::tvLM()` :

- Le cubique (*triweight*, utilisé par défaut) :
$$
K(u)=\frac{35}{32}\left(
1-
\left\lvert
x
\right\lvert^2
\right)^3\1_{[-1,1]}(x).
$$

- Le noyau d'Epanechnikov (ou parabolique) :
$$
K(u)=\frac{3}{4}\left(
1-
\left\lvert
x
\right\lvert^2
\right)\1_{[-1,1]}(x).
$$

- Le noyau Gaussien :
$$
K(u)=\frac{1}{\sqrt{2\pi}}\exp\left(-\frac{1}{2}x^2\right)
$$

Le paramètre $b_t$ permet de calibrer la largeur de la fenêtre (i.e., le nombre de points utilisés pour chaque estimation).
Il est généralement supposé constant ($b_t=b$).

Dans notre exemple de prévision du PIB, $T=160$ observations sont utilisées.
Avec $z_t=t/T$ et indexant chaque observation entre 1 et $T,$ la régression mobile sur 15 ans où l'on affecte le coefficient de la date $t$ au milieu de la fenêtre d'estimation est donc retrouvée en utilisant le noyau uniforme $K(u)=\1_{[-1,1]}(x)$ avec $b_t=b=\frac{30}{160}.$
En effet, dans ce cas $K(z_t-z_i)\ne0$ si et seulement si $|t-i|\leq30$ : on utilise donc 30 observations ($=7,5$ ans) autour de $t$ pour estimer le coefficient à la date $t.$

Dans `tvReg`, le paramètre $b$ est par défaut obtenu en minimisant une statistique de validation croisée dans l'intervalle $\left[\frac{5}{T},20\right].$
Lorsque $b$ est plus grand que 1, toutes les observations sont utilisées pour l'estimation de chaque coefficient $\bf\alpha_t.$
Plus $b$ se rapproche de 1 plus on se rapproche du cas de la régression linéaire puisque dans ce cas les poids donnés par $K$ tendent à être constants pour toutes les observations.
En effet, dans ce cas, pour $T=160,$ $\frac{\max_u K(u)}{\min_u K(u)}$ est compris entre $1,001$ et $1,008$ pour les noyaux cubiques, paraboliques et gaussiens.

Reprenons notre exemple de prévision du PIB avec une détection automatique de la fenêtre.

```{r}
reg_loc <- tvReg::tvLM(
  formula = growth_gdp ~ bc_fr_m1 + diff_bc_fr_m1,
  data = window(gdp, start = 1980, end = c(2019,4))
)
summary(reg_loc)
```
La fenêtre estimée par défaut est de `{r} formatC(reg_loc$bw, digits = 2, decimal.mark = ",")`, c'est-à-dire que pour estimer le coefficient à la date $t$ on utilise au plus `{r} round(reg_loc$bw*nrow(reg_lin$model)/4)` ans avant et après $t$ : on utilise tous les points dans la majorité des cas.
Cela explique le caractère très lisse des coefficients ([graphique @fig-coef-reg-mobile]).
Avec ce paramètre pour la fenêtre, les ruptures brutales sont donc difficiles à prendre en compte.


```{r}
#| echo: false
#| label: fig-coef-reg-mobile
#| fig-cap: Coefficients estimés par régression locale (avec $b=0,74$) et régression par morceaux.
# coef_roll_regres <- ts(coef_roll_regres, start = 1980+15/2-0.25,
#                        frequency = 4)
coef_pr <- coef(reg_morc)
coef_reg_loc <- ts(coef(reg_loc), start = 1980, frequency = 4)

coef2plot(
  list(
    "Reg. linéaire" = coef_lin,
    # "Reg. mobile" = coef_roll_regres,
    "Reg. par morceaux" = coef_pr,
    "Reg. locale" = coef_reg_loc
  )
)
```

Un des inconvénients de méthode de sélection automatique de la fenêtre est que la statistique de validation croisée est un critère peu discriminant (voir @Loader1999) : il peut y avoir très peu de différences entre différentes valeurs de la fenêtre alors que celle-ci a un impact fort sur l'interprétation du modèle !
Cela a également pour effet que la méthode est peu stable dans le temps ([figure @fig-oos-bw]), ce qui augmente les sources de révisions des simulations en temps réel, calculables en utilisant la fonction `oos_prev()` :

```{r}
oos_reg_loc <- oos_prev(reg_loc)
oos_bw <- ts(sapply(oos_reg_loc$model, `[[`,"bw"),
             end = c(2019, 4),
             frequency = 4)
```


```{r}
#| echo: false
#| label: fig-oos-bw
#| fig-cap: Fenêtre $b$ détectée automatique en fonction de la date de fin d'estimation du modèle.
autoplot(oos_bw) +
  # geom_abline(slope = 0, intercept = 1) +
  theme_bw() +
  labs(x = "Date de fin d'estimation",
       y = latex2exp::TeX("Fenêtre $b$"))
```

Pour l'estimation en temps réel, la méthode utilisée est l'utilisation d'une fonction de noyau tronquée : plus de points dans le passé que dans le futur sont utilisés pour estimer les derniers coefficients.
C'est donc également une source de révision au fur et à mesure que des nouveaux points seront connus.
Même si des méthodes optimales existent pour minimiser les erreurs d'estimation des coefficients en temps réel (voir par exemple @FengSchafer2021), cela devrait ici avoir peu d'impact car un modèle très simple est ici utilisé pour estimer les coefficients (approximation de la fonction $\alpha$ par une constante).


Un autre inconvénient de ces méthodes est que tous les coefficients varient dans la temps alors que dans certains cas on peut supposer la relation constante.
Si l'on souhaite fixer certains coefficients, on peut procéder comme dans la [section -@sec-test-baiperron] en faisant une régression linéaire, pour estimer les coefficients fixes, suivie d'une régression mobile.

## Modélisation espace-état {#sec-ssm}

La modélisation espace-état est une méthodologie générale permettant de traiter un grand nombre de problèmes de séries temporelles.
Dans cette approche, on suppose que tout modèle est déterminé par une série de vecteurs non observés $\alpha_1,\dots,\alpha_n$ associés aux observations $y_1,\dots,y_n$, la relation entre $\alpha_t$ et $y_t$ étant spécifiée par le modèle espace-état.
Ces modèles sont largement décrits dans la littérature, notamment par @durbinkoopman.
Dans cet article, nous nous placerons dans un cadre simplifié des modèles linéaires gaussiens appliqués aux régressions linéaires.
Les modèles sont déterminés par un ensemble de deux équations :
$$
\begin{cases}
y_t=\transp{\bf X_t}\bf\alpha_t+\varepsilon_t,\quad&\varepsilon_t\sim\mathcal N(0,\sigma^2)\\
\bf\alpha_{t+1}=\bf\alpha_t+\bf\eta_t,\quad&\bf\eta_t\sim\mathcal N(\bf 0,\bf\Sigma)
\end{cases},\text{ avec }\eta_t\text{ et }\varepsilon_t\text{ indépendants.}
$$
La première équation est l'équation d'observation (*observation equation*), la seconde l'équation d'état (*state equation*) et $\bf\alpha_t$ le vecteur d'états (*state vector*).

Dans cette étude, la matrice de variance-covariance $\bf\Sigma$ est supposée diagonale : la dynamique d'évolution des coefficients d'une variable est donc indépendante de la dynamique d'évolution des autres variables.
Lorsque des contraintes entre les différents coefficients existent, des spécifications différentes de la matrice de variance-covariance $\bf\Sigma$ peuvent être faites : c'est par exemple ce qui a été fait par @abs2006 pour estimer des coefficients jours ouvrables variant dans le temps.
On retrouve le cas de la régression linéaire lorsque $\bf\Sigma=\bf 0$ puisque dans ce cas tous les $\alpha_t$ sont égaux.

Ces modèles sont implémentés dans la fonction `tvCoef::ssm_lm()` qui prend en entrée un modèle de régression linéaire.
L'implémentation est basée sur le package `rjd3sts` [@rjd3sts] qui permet d'implémenter très facilement les modèles espaces-état sans devoir écrire explicitement le modèle.
Par défaut les variances du vecteur d'états ($\bf \Sigma$) ne sont pas estimés et fixés à 0 : on retrouve donc les coefficients estimés par régression linéaire.

```{r}
ssm <- ssm_lm(reg_lin)
ssm
```

L'estimation des hyperparamètres (variances des bruits blancs) est faite par maximum de vraisemblance différentes méthodes existent pour initialiser les modèles (calculer $\bf \alpha_1$).
Pour plus de détails voir par exemple @durbinkoopman.
Le filtre de Kalman permet ensuite de calculer toutes les coefficients.
Parmi les paramètres calculés, les deux principaux sont : 

1. Les états lissés (*smoothed states*) : il s'agit de l'estimation des états ($\bf\alpha_t$) en utilisant toute l'information disponible disponible : $\E{\alpha_t|y_1,\dots,y_n}.$
Dans le cadre de la régression linéaire, les états lissés sont donc constants sur toutes les dates et correspondent aux coefficients estimés en utilisant l'ensemble des données disponibles :

```{r}
window(ssm$smoothed_states, start = 2019)
```

2. Les états filtrés (*filtered states*) : il s'agit de l'estimation des états ($\bf\alpha_t$) en utilisant l'information disponible jusqu'à la date précédente : $\E{\alpha_t|y_1,\dots,y_{t-1}}.$
Dans le cadre de la régression linéaire, cela correspond aux coefficients estimés en temps réel : la valeur des états filtrés en 2010T2 correspond aux coefficients estimés en utilisant les données jusqu'au 2010T1.
Ils permettent donc d'avoir une estimation en temps réel des prévisions du modèle.
```{r}
round(window(ssm$filtering_states, start = c(2010, 2), end = c(2010, 2)), 6)
round(coef(dynlm(
  formula = growth_gdp ~ bc_fr_m1 + diff_bc_fr_m1,
  data = window(gdp, start = 1980, end = c(2010,1))
)), 6)
```
Lorsque les variances sont estimées, les états filtrés ne correspondent pas à exactement à des estimations en temps réel car les hyperparamètres sont fixés (variances $\bf\Sigma$ et initialisation).
Les estimations en temps réel peuvent être calculées en utilisant la fonction `tvCoef::ssm_lm_oos()`.

Pour faciliter l'estimation des variances $\bf\Sigma,$ le paramètre est souvent reparamétré :

$$
\begin{cases}
y_t=\transp{\bf X_t}\bf\alpha_t+\varepsilon_t,\quad&\varepsilon_t\sim\mathcal N(0,\sigma^2)\\
\bf\alpha_{t+1}=\bf\alpha_t+\bf\eta_t,\quad&\bf\eta_t\sim\mathcal N(\bf 0,\sigma^2\bf Q)
\end{cases},\text{ avec }\eta_t\text{ et }\varepsilon_t\text{ indépendants.}
$$

```{r}
sqrt(ssm$parameters$parameters *
ssm$parameters$scaling)
```



texte sur la variance des coefficients.





Smoothing, filtering

```{r}
ssm_lm(reg_lin)
```

## Autres modèles

Modèles à seuil et à changement de régime

# Comparaison générale

## Données utilisées

## Résultats

tableau agrégé


# Conclusion


# Installation de `tvCoef` {.appendix}


Pour utiliser `tvCoef`, il faut il faut avoir la version 17 de Java SE (ou une version supérieure).

Pour savoir quelle version de Java est utilisée par R, utiliser le code suivant :
```{r}
#| eval: false
library(rJava)
.jinit()
.jcall("java/lang/System", "S", "getProperty", "java.runtime.version")
```

Si le résultat n'est pas sous la forme `"17xxxx"` c'est que vous n'avez pas Java 17 !

Si l'on a pas cette version d'installée et que l'on n'a pas les droits d'administrateur pour installer Java, une solution est d'installer une version portable de Java, par exemple installer une version portable à partir des liens suivants :

- [Zulu JDK](https://www.azul.com/downloads/#zulu)

- [AdoptOpenJDK](https://adoptopenjdk.net/)

- [Amazon Corretto](https://aws.amazon.com/corretto/)

Pour installer une version portable de java, télécharger par exemple le fichier `Windows 10 x64 Java Development Kit` disponible sur <https://jdk.java.net/java-se-ri/17>, le dézipper et le mettre par exemple sous `""`.  

Pour configurer R avec une version portable de Java, trois solutions :

1. Avant **avant tout chargement de package nécessitant Java (`rJava`...)** (si vous avez lancé le code précédent, relancez donc R) :
```{r, eval = FALSE}
# Si la version portable est installée sous D:/Programmes/jdk-17
Sys.setenv(JAVA_HOME='D:/Programmes/jdk-17')
```

2. Pour éviter de faire cette manipulation à chaque fois que l'on relance R, deux solutions :  

a. modifier le `JAVA_HOME` dans les variables d'environnement de Windows (voir <https://confluence.atlassian.com/doc/setting-the-java_home-variable-in-windows-8895.html>).

b. modifier le `.Renviron` : depuis R lancer le code `file.edit("~/.Renviron")`{.r}, ajouter dans le fichier le chemin vers la version portable de Java comme précédemment (`JAVA_HOME='D:/Programmes/jdk-17'`), sauvegarder et relancer R.

Il reste maintenant à installer les packages :

```{r, eval = FALSE}
remotes::install_github("rjdemetra/rjd3toolkit")
remotes::install_github("rjdemetra/rjd3sts")
remotes::install_github("InseeFrLab/tvCoef")
```

Si vous utilisez un ordinateur professionnel, si c'est nécessaire,pensez à configurer le proxy pour que ces commandes puissent fonctionner (voir <https://www.book.utilitr.org/01_r_insee/fiche-personnaliser-r#le-fichier-.renviron>).
Pour cela vous pouvez utiliser `curl::ie_get_proxy_for_url()` pour récupérer l'adresse du proxy et ajouter deux variable `http_proxy` et `https_proxy` dans les variables d'environnement (comme précédemment).

<!-- {{< pagebreak >}} -->

# Bibliographie {-}

::: {#refs}
:::