<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Alain Quartier-la-Tente">

<title>Utilisation de modèles de régression à coefficients variant dans le temps pour la prévision conjoncturelle</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="DT-tvcoef_files/libs/clipboard/clipboard.min.js"></script>
<script src="DT-tvcoef_files/libs/quarto-html/quarto.js"></script>
<script src="DT-tvcoef_files/libs/quarto-html/popper.min.js"></script>
<script src="DT-tvcoef_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="DT-tvcoef_files/libs/quarto-html/anchor.min.js"></script>
<link href="DT-tvcoef_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="DT-tvcoef_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="DT-tvcoef_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="DT-tvcoef_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="DT-tvcoef_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<link href="DT-tvcoef_files/libs/quarto-contrib/fontawesome6-0.1.0/all.css" rel="stylesheet">
<link href="DT-tvcoef_files/libs/quarto-contrib/fontawesome6-0.1.0/latex-fontsize.css" rel="stylesheet">
<script type="application/json" class="js-hypothesis-config">
{
  "theme": "clean"
}
</script>
<script async="" src="https://hypothes.is/embed.js"></script>
<script>
  window.document.addEventListener("DOMContentLoaded", function (_event) {
    document.body.classList.add('hypothesis-enabled');
  });
</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="template/style.css">
</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table des matières</h2>
   
  <ul>
  <li><a href="#résumé" id="toc-résumé" class="nav-link active" data-scroll-target="#résumé">Résumé</a></li>
  <li><a href="#abstract" id="toc-abstract" class="nav-link" data-scroll-target="#abstract">Abstract</a></li>
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction"><span class="header-section-number">1</span> Introduction</a></li>
  <li><a href="#sec-tests" id="toc-sec-tests" class="nav-link" data-scroll-target="#sec-tests"><span class="header-section-number">2</span> Modélisation générale et tests</a>
  <ul class="collapse">
  <li><a href="#sec-test-baiperron" id="toc-sec-test-baiperron" class="nav-link" data-scroll-target="#sec-test-baiperron"><span class="header-section-number">2.1</span> Test de rupture brutale</a></li>
  <li><a href="#sec-hansen-test" id="toc-sec-hansen-test" class="nav-link" data-scroll-target="#sec-hansen-test"><span class="header-section-number">2.2</span> Test de constance des coefficients</a></li>
  </ul></li>
  <li><a href="#sec-desc-meth" id="toc-sec-desc-meth" class="nav-link" data-scroll-target="#sec-desc-meth"><span class="header-section-number">3</span> Descriptions des méthodes</a>
  <ul class="collapse">
  <li><a href="#sec-reg-morceaux" id="toc-sec-reg-morceaux" class="nav-link" data-scroll-target="#sec-reg-morceaux"><span class="header-section-number">3.1</span> Régression par morceaux</a></li>
  <li><a href="#sec-reg-locale" id="toc-sec-reg-locale" class="nav-link" data-scroll-target="#sec-reg-locale"><span class="header-section-number">3.2</span> De la régression mobile à la régression locale</a></li>
  <li><a href="#sec-ssm" id="toc-sec-ssm" class="nav-link" data-scroll-target="#sec-ssm"><span class="header-section-number">3.3</span> Modélisation espace-état</a></li>
  <li><a href="#prise-en-compte-de-la-période-du-covid-19-et-prévision" id="toc-prise-en-compte-de-la-période-du-covid-19-et-prévision" class="nav-link" data-scroll-target="#prise-en-compte-de-la-période-du-covid-19-et-prévision"><span class="header-section-number">3.4</span> Prise en compte de la période du COVID-19 et prévision</a></li>
  </ul></li>
  <li><a href="#sec-comp-generales" id="toc-sec-comp-generales" class="nav-link" data-scroll-target="#sec-comp-generales"><span class="header-section-number">4</span> Comparaison générale</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion"><span class="header-section-number">5</span> Conclusion</a></li>
  
  <li><a href="#bibliographie" id="toc-bibliographie" class="nav-link" data-scroll-target="#bibliographie">Bibliographie</a></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Autres formats</h2><ul><li><a href="DT-tvcoef.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div><div class="quarto-code-links"><h2>Liens de code</h2><ul><li><a href="https://github.com/AQLT/DT-tvcoef"><i class="bi bi-github"></i>InseeFrLab/DT-tvcoef</a></li></ul></div></nav>
</div>
<main class="content" id="quarto-document-content">
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    TeX: {Macros: {
            E: "{\\mathbb{E}}"
        },
        Augment: {
        Definitions: {
          delimiter: {
            "\\llbracket": '\u27E6',
            '\\rrbracket': '\u27E7'
          }}
        }}
    });
</script>
    
    <div style="display:none" aria-hidden="true">
    \(

        \newcommand\llbracket{[\![}
        \newcommand\rrbracket{]\!]}
        \newcommand\1{{\mathbb 1}}
        \newcommand\ud{\,\mathrm{d}}
        \newcommand{\transp}[1]{{}^t\!#1}
        \newcommand{\bf}[1]{{\boldsymbol #1}}
        \newcommand{\E}[1]{\mathbb{E}\left[#1\right]}
        \DeclareMathOperator*{\argmax}{argmax}
        \DeclareMathOperator*{\argmin}{argmin}
    \)
    </div>
    

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Utilisation de modèles de régression à coefficients variant dans le temps pour la prévision conjoncturelle</h1>
</div>


<div class="quarto-title-meta-author">
  <div class="quarto-title-meta-heading">Auteur</div>
  <div class="quarto-title-meta-heading">Affiliation</div>
  
    <div class="quarto-title-meta-contents">
    <p class="author">Alain Quartier-la-Tente </p>
  </div>
  <div class="quarto-title-meta-contents">
        <p class="affiliation">
            <a href="https://www.insee.fr/fr/">
            Insee
            </a>
          </p>
      </div>
  </div>

<div class="quarto-title-meta">

      
  
    
  </div>
  


</header>


<!-- \thispagestyle{fancy} -->
<p>Remerciements :</p>
<div style="page-break-after: always;"></div>
<section id="résumé" class="level1 unnumbered">
<h1 class="unnumbered">Résumé</h1>
<div class="abstract">
<p>Cette étude décrit trois méthodes d’estimation de modèles de régression linéaire avec des coefficients variant dans le temps : régression par morceaux, régression locale et modélisation espace-état. Elle détaille également leur implémentation sous R grâce au package <code>tvCoef</code>. À travers une analyse comparative sur une trentaine de modèles de prévision trimestrielle, nous démontrons que l’utilisation de ces méthodes, notamment la modélisation espace-état, réduit les erreurs de prévision lorsque des ruptures sont présentes dans les coefficients. Par ailleurs, même lorsque les tests classiques concluent à la constance des coefficients, la modélisation espace-état peut permettre de réduire les erreurs de prévision. Cependant, les incertitudes liées à l’estimation de certains hyperparamètres peuvent augmenter les erreurs de prévision en temps réel, en particulier pour la régression locale. Ainsi, une analyse économique des paramètres estimés demeure essentielle.</p>
<p>Cette étude est entièrement reproductible et tous les codes utilisés sont disponibles sous <a href="https://github.com/InseeFrLab/DT-tvcoef" class="uri">https://github.com/InseeFrLab/DT-tvcoef</a>.</p>
<p>Mots clés : séries temporelles, prévisions, séries longues.</p>
</div>
</section>
<section id="abstract" class="level1 unnumbered">
<h1 class="unnumbered">Abstract</h1>
<div class="abstract">
<p>This study describes three methods for estimating linear regression models with time-varying coefficients: piecewise regression, local regression, and state-space modeling. It also details their implementation in R using the <code>tvCoef</code> package. Through a comparative analysis of around thirty quarterly forecasting models, we demonstrate that the use of these methods, especially state-space modeling, reduces forecast errors when breakpoints are present in the coefficients. Moreover, even when traditional tests conclude stability of coefficients, state-space modeling can still improve forecasts. However, uncertainties related to estimating certain hyperparameters can increase real-time forecast errors, especially for local regression. Thus, an economic analysis of estimated parameters remains essential.</p>
<p>This study is fully reproducible and all the codes used are available under <a href="https://github.com/InseeFrLab/DT-tvcoef" class="uri">https://github.com/InseeFrLab/DT-tvcoef</a>.</p>
<p>Keywords: time series, forecast, long time series.</p>
</div>
<p>JEL Classification: C22, C53.</p>
<div style="page-break-after: always;"></div>
</section>
<section id="introduction" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Introduction</h1>
<p>Dans la statistique publique, de nombreux modèles de prévision s’appuient sur des régressions linéaires. Par exemple, les producteurs de séries désaisonnalisées appliquent des modèles RegARIMA pour la correction des effets de calendrier et les comptes. Pour la prévision des grands agrégats macroéconomiques, l’Insee <span class="citation" data-cites="ndc2015prev">(e.g., <a href="#ref-ndc2015prev" role="doc-biblioref">Glotain et Quartier-la-Tente 2015</a>)</span> et la Banque de France <span class="citation" data-cites="OPTIM">(e.g., <a href="#ref-OPTIM" role="doc-biblioref">Barhoumi et al. 2008</a>)</span> utilisent notamment des modèles de régression linéaire pour prévoir la croissance et le modèle macroéconomique Mésange <span class="citation" data-cites="mesange">(<a href="#ref-mesange" role="doc-biblioref">Bardaji et al. 2017</a>)</span> s’appuie sur des modèles à correction d’erreur pour modéliser les comportements macroéconomiques. Ces méthodes fournissent généralement de bons résultats et ont l’avantage d’être facilement interprétables. Cependant, ils supposent que les relations entre les variables (i.e, les coefficients estimés) sont fixes dans le temps&nbsp;: cette hypothèse peut avoir du sens sur courte période mais n’est généralement plus vérifiée lorsque les modèles sont estimés sur longue période, ce qui conduit à des modèles sous-optimaux.</p>
<p>Pour palier à ce problème, une solution simple consiste à utiliser moins de données pour estimer les modèles. Par exemple, le guide des bonnes pratiques sur l’ajustement saisonnier <span class="citation" data-cites="eurostat2015guidelines">(<a href="#ref-eurostat2015guidelines" role="doc-biblioref">Eurostat 2015</a>)</span> recommandent de ne pas désaisonnaliser des séries de plus de 20 ans. Toutefois, cela conduit à perdre l’historique des données et l’information que l’on peut en tirer et ne résout pas le problème lorsque la rupture est récente. Par ailleurs, comme montré par <span class="citation" data-cites="JMS2018">Pham et Quartier-la-Tente (<a href="#ref-JMS2018" role="doc-biblioref">2018</a>)</span> pour la désaisonnalisation des séries d’indice de production industrielle, lorsqu’il faut analyser les modèles sur l’ensemble de la période (par exemple dans le cadre de la correction des jours ouvrables), il est nécessaire de mettre en place des méthodes de chaînage afin de prendre en compte la rupture introduite par l’utilisation de plusieurs modèles. Ainsi, dans certains cas il peut être préférable d’utiliser des modèles qui prennent directement en compte les ruptures.</p>
<p>L’objectif de cette étude est d’étudier différentes méthodes d’estimation de coefficients variant dans le temps dans le cadre de la prévision conjoncturelle. Cela permet d’avoir des modèles qui ont l’avantage d’être plus facilement interprétables que des méthodes de machine learning, puisqu’ils s’appuient sur des modèles de régression linéaire. Ces méthodes se regroupent en trois catégories : les modèles de régression par morceaux, les régressions locales et les modèles espace-état. La première suppose l’existence d’une rupture brutale sur les coefficients à une certaine date ; les deux autres supposent que les coefficients évoluent progressivement sans le temps sans existence de rupture brutale. Pour simplifier l’implémentation de ces méthodes, ainsi que leur comparaison, le package R <code>tvCoef</code> (<a href="https://github.com/InseeFrLab/tvCoef" class="uri">https://github.com/InseeFrLab/tvCoef</a>) a également été développé lors de cette étude. Cette étude est entièrement reproductible et tous les codes utilisés sont disponibles sous <a href="https://github.com/InseeFrLab/DT-tvcoef" class="uri">https://github.com/InseeFrLab/DT-tvcoef</a>.</p>
<p>Après une description de deux tests permettant vérifier si les coefficients sont fixes dans le temps (<a href="#sec-tests" class="quarto-xref">section&nbsp;2</a>), nous décrivons trois méthodes pour estimer des coefficients variant dans le temps et montrons comment les implémenter à partir d’un modèle de prévision de la croissance du PIB français (<a href="#sec-desc-meth" class="quarto-xref">section&nbsp;3</a>). Enfin, nous comparons les qualités prédictives des différentes méthodes sur une trentaine de modèles de prévision trimestrielle (<a href="#sec-comp-generales" class="quarto-xref">section&nbsp;4</a>). Nous montrons que, lorsque l’hypothèse de constance des coefficients n’est pas vérifiée, l’utilisation de ces modèles (notamment la modélisation espace-état) permet de réduire les erreurs de prévision. Par ailleurs, même lorsque les tests classiques concluent à la constance des coefficients, la modélisation espace-état peut permettre de réduire les erreurs de prévision.</p>
</section>
<section id="sec-tests" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Modélisation générale et tests</h1>
<p>Dans cet article, nous nous placerons dans le cadre de la régression linéaire avec des variables à une dimension. À chaque date <span class="math inline">\(t\)</span>, la variable <span class="math inline">\(y_t\)</span> (e.g., taux de croissance du PIB) est expliquée par une combinaison linéaire de <span class="math inline">\(p\)</span> variables explicatives, <span class="math inline">\(x_{0,t},\dots,x_{p,t}\)</span> (soldes d’opinion, indices de production industrielle, indicatrices, etc.) : <span class="math display">\[
y_t=\alpha_{0}+\alpha_{1} x_{1,t}+\dots+\alpha_{p} x_{p,t} +\varepsilon_t
\]</span> où <span class="math inline">\(\varepsilon_t\)</span> représente l’erreur d’approximation. En notant <span class="math inline">\({\bf X}_t=\begin{pmatrix}1 &amp; x_{1,t} &amp;\cdots &amp; x_{p,t} \end{pmatrix}\)</span> et <span class="math inline">\({\bf \alpha}=\transp{\begin{pmatrix}\alpha_0 &amp; \alpha_1 &amp;\cdots &amp; \alpha_p \end{pmatrix}}\)</span>, cela s’écrit matriciellement&nbsp;: <span class="math display">\[
y_t={\bf X_t} \bf\alpha +\varepsilon_t.
\]</span></p>
<p>Dans le cadre de la régression linéaire, les coefficients <span class="math inline">\(\bf\alpha\)</span> sont supposés constants dans le temps et estimés en utilisant l’ensemble des données. Cela suppose donc que la relation économique entre les différentes variables est stable dans le temps. Même si cette hypothèse est généralement vraie sur le court-terme, elle peut être invalidée sur le long-terme du fait de changements structurels (mesures économiques, crises, changement de nomenclature, etc.) L’objectif de cet article est d’étudier différent modèles permettant de relâcher cette hypothèse de constance des coefficients. Le modèle général s’écrit donc : <span class="math display">\[
y_t={\bf X_t} \bf\alpha_t  +\varepsilon_t.
\]</span> Pour faciliter l’utilisation des modèles ici présentés, le package <i class="fa-brands fa-r-project" aria-label="r-project"></i> <code>tvCoef</code> <span class="citation" data-cites="tvcoef">(<a href="#ref-tvcoef" role="doc-biblioref">de Rosamel et Quartier-la-Tente 2024</a>)</span> a été développé pour cette étude.</p>
<p>Les différentes méthodes seront illustrées à travers l’exemple de la prévision du taux de croissance trimestriel du PIB à partir du climat des affaires France publié par l’Insee<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. Ces séries sont disponibles sous <i class="fa-brands fa-r-project" aria-label="r-project"></i> dans la base de donnée <code>tvCoef::gdp</code> :</p>
<ul>
<li><p><code>growth_gdp</code> correspond au taux de croissance trimestriel du PIB ;</p></li>
<li><p><code>bc_fr_m1</code> correspond au climat des affaires au premier mois de chaque trimestre (la valeur de 2000T1 correspond à la valeur de janvier 2000, celle de 2000T2 à celle d’avril 2000, etc.) ;</p></li>
<li><p><code>diff_bc_fr_m1</code> correspond à la différenciation trimestrielle de la variable précédente (la valeur de 2000T1 correspond à la différence du climat des affaires entre de janvier 2000 et octobre 1999).</p></li>
</ul>
<p>Le modèle s’écrit donc : <span class="math display">\[
\% PIB_t=\alpha_0 + \alpha_1\times climat\_fr_t^{m_1} + \alpha_2\times \Delta climat\_fr_t^{m_1}+\varepsilon_t.
\]</span></p>
<p>Il est estimé en utilisant les données entre les années 1980 et 2019. Sous <i class="fa-brands fa-r-project" aria-label="r-project"></i>, ce modèle peut être estimé en utilisant la fonction <code>stats::lm()</code>. Toutefois, nous recommandons d’utiliser le package <code>dynlm</code> <span class="citation" data-cites="dynlm">(<a href="#ref-dynlm" role="doc-biblioref">Zeileis 2019</a>)</span> qui offre une plus grande flexibilité dans la définition des modèles et de conserver le format série temporelle dans les fonctions de <code>tvCoef</code>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tvCoef)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(dynlm)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>data_gdp <span class="ot">&lt;-</span> <span class="fu">window</span>(gdp, <span class="at">start =</span> <span class="dv">1980</span>, <span class="at">end =</span> <span class="fu">c</span>(<span class="dv">2019</span>, <span class="dv">4</span>))</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>reg_lin <span class="ot">&lt;-</span> <span class="fu">dynlm</span>(</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">formula =</span> growth_gdp <span class="sc">~</span> bc_fr_m1 <span class="sc">+</span> diff_bc_fr_m1,</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="at">data =</span> data_gdp</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co"># # Equivalent à :</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co"># reg_lin &lt;- dynlm(</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co">#   formula = growth_gdp ~ bc_fr_m1 + diff(bc_fr_m1, 1),</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co">#   # Date de début changée car on perd une donnée avec la différenciation</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co">#   data = window(gdp, start = c(1979, 4), end = c(2019, 4))</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co"># )</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="fu">coefficients</span>(reg_lin)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  (Intercept)      bc_fr_m1 diff_bc_fr_m1 
  -1.63769798    0.02084469    0.04215106 </code></pre>
</div>
</div>
<p>Le modèle estimé est donc :</p>
<p><span class="math display">\[\% PIB_t=-1.64 + 0.02\times climat\_fr_t^{m_1} + 0.04\times \Delta climat\_fr_t^{m_1}+{\hat\varepsilon}_t.\]</span></p>
<section id="sec-test-baiperron" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="sec-test-baiperron"><span class="header-section-number">2.1</span> Test de rupture brutale</h2>
<p>L’idée la plus simple pour tester s’il y a une rupture dans l’estimation des coefficients à une date <span class="math inline">\(t_1\)</span>, est d’estimer deux sous-modèles avant et après cette date : <span class="math display">\[
\begin{cases}
\forall t \leq t_1 :\quad \% PIB_t = \alpha_0' + \alpha_1' climat\_fr_t + \alpha_2' \Delta climat\_fr_t + \varepsilon_t' \\
\forall t &gt; t_1 :\quad \% PIB_t = \alpha_0'' + \alpha_1'' climat\_fr_t + \alpha_2'' \Delta climat\_fr_t + \varepsilon_t''
\end{cases}.
\]</span> Il ne reste ensuite qu’à tester si les coefficients estimés entre les deux sous-périodes sont égaux&nbsp;: <span class="math inline">\(\alpha_0' = \alpha_0''\)</span>, <span class="math inline">\(\alpha_1' = \alpha_1''\)</span> et <span class="math inline">\(\alpha_2' = \alpha_2''.\)</span> L’hypothèse alternative et qu’au moins un des coefficients est différent entre les deux sous-périodes. C’est le principe du test de <span class="citation" data-cites="chowtest">Chow (<a href="#ref-chowtest" role="doc-biblioref">1960</a>)</span>.</p>
<p>L’inconvénient est que cela suppose d’avoir un a priori sur la date de la rupture à tester. Pour palier à ce problème, <span class="citation" data-cites="bai2003computation">Bai et Perron (<a href="#ref-bai2003computation" role="doc-biblioref">2003</a>)</span> ont proposé un algorithme efficace afin de chercher la présence de ruptures multiples dans des modèles de régression linéaire. Cet algorithme a été implémenté sous <i class="fa-brands fa-r-project" aria-label="r-project"></i> dans le package <code>strucchange</code> <span class="citation" data-cites="strucchangeBP">(<a href="#ref-strucchangeBP" role="doc-biblioref">Zeileis et al. 2003</a>)</span>. La fonction <code>strucchange::breakpoints()</code> permet de chercher les ruptures et la fonction <code>strucchange::breakdates()</code> d’extraire facilement les dates associées. Le package <code>tvCoef</code> implémente une méthode <code>breakpoints.lm()</code> afin de pouvoir directement appliquer cette fonction aux régressions linéaires estimées :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(strucchange)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>bp <span class="ot">&lt;-</span> <span class="fu">breakpoints</span>(reg_lin)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="fu">breakdates</span>(bp)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 2000.25</code></pre>
</div>
</div>
<p>Une seule rupture est détectée au 2000T2. Un intervalle de confiance autour de la date détectée peut être calculée peut en utilisant la fonction <code>confint()</code> :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">breakdates</span>(<span class="fu">confint</span>(bp))</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  2.5 % breakpoints  97.5 %
1  1996     2000.25 2004.75</code></pre>
</div>
</div>
<p>L’incertitude autour de la date détectée est grande ! Il y a 95 % de chance que la rupture soit comprise entre 1996T1 et 2004T4.</p>
<p>Cet algorithme est très simple à utiliser mais possède plusieurs inconvénients :</p>
<ul>
<li><p>L’implémentation sous <i class="fa-brands fa-r-project" aria-label="r-project"></i> de l’algorithme de Bai et Perron ne permet pas de chercher des ruptures sur un sous-ensemble de variables : on ne cherche des ruptures que sur l’ensemble du modèle. Par exemple, on ne peut pas tester <span class="math inline">\(\alpha_2' = \alpha_2''\)</span> dans le modèle : <span class="math display">\[
\begin{cases}
\forall t \leq t_1 :\quad \% PIB_t = \alpha_0 + \alpha_1 climat\_fr_t + \alpha_2' \Delta climat\_fr_t + \varepsilon_t' \\
\forall t &gt; t_1 :\quad \% PIB_t = \alpha_0 + \alpha_1 climat\_fr_t + \alpha_2'' \Delta climat\_fr_t + \varepsilon_t''
\end{cases}.
\]</span> Une solution simple est d’effectuer une première régression sur l’ensemble des données afin d’estimer <span class="math inline">\(\alpha_0\)</span> et <span class="math inline">\(\alpha_1\)</span> et d’ensuite appliquer la procédure de Bai et Perron sur le modèle&nbsp;: <span class="math display">\[
\begin{cases}
\forall t \leq t_1 :\quad (\% PIB - \hat\alpha_0-\hat \alpha_1 climat\_fr)_t = \alpha_2' \Delta climat\_fr_t + \varepsilon_t' \\
\forall t &gt; t_1 :\quad (\% PIB - \hat\alpha_0-\hat \alpha_1 climat\_fr)_t = \alpha_2'' \Delta climat\_fr_t + \varepsilon_t''
\end{cases}.
\]</span></p></li>
<li><p>Il y a une instabilité sur le choix de la date et il suppose que la rupture est brutale à une certaine date. Si la rupture est brutale, le statisticien doit pouvoir expliquer son origine (changement de nomenclature, de champ dans les données, crise…) et a déjà un a priori sur la date de rupture. Si l’on n’a aucune information sur la présence d’une rupture, on peut raisonnablement penser que celle-ci n’est pas brutale mais que la relation entre les variables a évolué de manière progressive dans le temps.</p></li>
</ul>
</section>
<section id="sec-hansen-test" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="sec-hansen-test"><span class="header-section-number">2.2</span> Test de constance des coefficients</h2>
<p>Alors que l’algorithme de Bai et Perron cherche une date spécifique où il y aurait une rupture dans les modèles, <span class="citation" data-cites="hansen1992testing">Hansen (<a href="#ref-hansen1992testing" role="doc-biblioref">1992a</a>)</span> propose une procédure permettant de tester uniquement si les coefficients sont constants ou non sans hypothèse sur la forme de la rupture (brutale ou non) et sur la date de la rupture.</p>
<p>En repartant de la modélisation générale de la régression linéaire : <span class="math display">\[\begin{align*}
y_t&amp;=\alpha_{0}x_{0,t}+\alpha_{1} x_{1,t}+\dots+\alpha_{p} x_{p,t} +\varepsilon_t  \\
&amp;= {\bf X_t} \bf\alpha  +\varepsilon_t\\
\E{\varepsilon_t|x_t}&amp;=0 \text{ (exogénéité stricte)} \\
\E{\varepsilon_t^2}&amp;=\sigma_t^2\text{ et } \underset{n\to\infty}{\lim}\frac{1}{n}\sum_{t=1}^n\sigma_t^2=\sigma.
\end{align*}\]</span> On suppose également que toutes les variables sont faiblement dépendantes (cas général de la régression linéaire). Les variables ne doivent donc pas contenir de tendance déterministe ou stochastique (comme des racines unitaires).</p>
<p>Le test consiste à tester si l’ensemble des paramètres <span class="math inline">\((\alpha,\sigma^2)\)</span> sont constants. L’hypothèse alternative est qu’au moins un paramètre suit une martingale.</p>
<p>Notons <span class="math inline">\({\hat \varepsilon}_t =y_t- {\bf X_t} \hat{\bf\alpha}\)</span> et <span class="math display">\[
f_{i,t} = \begin{cases}
x_{i,t}\hat \varepsilon_t &amp;\text{ si }i\leq p\\
\hat \varepsilon_t^2 - \hat \sigma^2&amp;\text{ si }i=p+1
\end{cases}
\text{ et }S_{i,t} = \sum_{j=1}^tf_{i,j}\qquad(\text{N.B : }S_{i,n}=0)
\]</span> D’après les conditions de premier ordre <span class="math inline">\(S_{i,n}=0.\)</span></p>
<p>Le test individuel de constance du coefficient du paramètre <span class="math inline">\(i\)</span> est : <span class="math display">\[
L_i=\frac{1}{nV_i}\sum_{t=1}^nS_{i,t}^2\qquad
\text{avec }V_i=\sum_{t=1}^nf_{i,t}^2.
\]</span></p>
<p>Notons : <span class="math display">\[
\bf f_t= \begin{pmatrix}
f_{1,t} \\ \vdots \\ f_{p+1,t}
\end{pmatrix} \text{ et }
\bf S_t= \begin{pmatrix}
S_{1,t} \\ \vdots \\ S_{p+1,t}
\end{pmatrix}.
\]</span> Le test joint de constance de l’ensemble des paramètres est : <span class="math display">\[
L_c = \frac{1}{n}
\sum_{t=1}^n\transp{\bf S_t}\bf V^{-1}\bf S_t
\text{ avec }\bf V=\sum_{t=1}^n\bf f_{t}\transp{\bf f_{t}}.
\]</span> Il s’adapte facilement à un test de joint de constance d’un sous-ensemble de paramètres en utilisant des sous-vecteurs de <span class="math inline">\(\bf f_t\)</span> et <span class="math inline">\(\bf S_t.\)</span> Toutefois, si modèle contient des indicatrices alors le test joint ne pourra pas être calculé (la matrice <span class="math inline">\(\bf V\)</span> n’est alors pas inversible).</p>
<p>Sous l’hypothèse nulle de constance des paramètres, les <span class="math inline">\(S_{i,t}\)</span> devraient tendre vers 0 (à la manière d’une marche aléatoire contrainte) : les statistiques de test <span class="math inline">\(L_i\)</span> et <span class="math inline">\(L_c\)</span> devraient donc être petites. Sous l’hypothèse alternative d’instabilité des paramètres, la somme cumulée des <span class="math inline">\(S_{i,t}\)</span> devrait ne pas être de moyenne nulle dans un sous-ensemble de l’échantillon et la statistique de test devrait être élevée. L’hypothèse nulle de stabilité des coefficients est donc rejetée lorsque la statistique de test est grande. Sous l’hypothèse nulle, la loi de distribution asymptotique est non standard, les valeurs critiques sont présentées dans la <a href="#tbl-hansen-table" class="quarto-xref">table&nbsp;1</a>.</p>
<div id="tbl-hansen-table" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-hansen-table-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;1- Valeurs critiques asymptotiques pour <span class="math inline">\(L_c\)</span> en fonction du nombre de paramètres testés (1 degré de liberté pour <span class="math inline">\(L_i\)</span>).
</figcaption>
<div aria-describedby="tbl-hansen-table-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell">
<div class="cell-output-display">
<table class="table table-sm table-striped small">
<thead>
<tr class="header">
<th style="text-align: right;">Degrés de liberté</th>
<th style="text-align: right;">1 %</th>
<th style="text-align: right;">2,5 %</th>
<th style="text-align: right;">5 %</th>
<th style="text-align: right;">7,5 %</th>
<th style="text-align: right;">10 %</th>
<th style="text-align: right;">20 %</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">1</td>
<td style="text-align: right;">0,748</td>
<td style="text-align: right;">0,593</td>
<td style="text-align: right;">0,470</td>
<td style="text-align: right;">0,398</td>
<td style="text-align: right;">0,353</td>
<td style="text-align: right;">0,243</td>
</tr>
<tr class="even">
<td style="text-align: right;">2</td>
<td style="text-align: right;">1,070</td>
<td style="text-align: right;">0,898</td>
<td style="text-align: right;">0,749</td>
<td style="text-align: right;">0,670</td>
<td style="text-align: right;">0,610</td>
<td style="text-align: right;">0,469</td>
</tr>
<tr class="odd">
<td style="text-align: right;">3</td>
<td style="text-align: right;">1,350</td>
<td style="text-align: right;">1,160</td>
<td style="text-align: right;">1,010</td>
<td style="text-align: right;">0,913</td>
<td style="text-align: right;">0,846</td>
<td style="text-align: right;">0,679</td>
</tr>
<tr class="even">
<td style="text-align: right;">4</td>
<td style="text-align: right;">1,600</td>
<td style="text-align: right;">1,390</td>
<td style="text-align: right;">1,240</td>
<td style="text-align: right;">1,140</td>
<td style="text-align: right;">1,070</td>
<td style="text-align: right;">0,883</td>
</tr>
<tr class="odd">
<td style="text-align: right;">5</td>
<td style="text-align: right;">1,880</td>
<td style="text-align: right;">1,630</td>
<td style="text-align: right;">1,470</td>
<td style="text-align: right;">1,360</td>
<td style="text-align: right;">1,280</td>
<td style="text-align: right;">1,080</td>
</tr>
<tr class="even">
<td style="text-align: right;">6</td>
<td style="text-align: right;">2,120</td>
<td style="text-align: right;">1,890</td>
<td style="text-align: right;">1,680</td>
<td style="text-align: right;">1,580</td>
<td style="text-align: right;">1,490</td>
<td style="text-align: right;">1,280</td>
</tr>
<tr class="odd">
<td style="text-align: right;">7</td>
<td style="text-align: right;">2,350</td>
<td style="text-align: right;">2,100</td>
<td style="text-align: right;">1,900</td>
<td style="text-align: right;">1,780</td>
<td style="text-align: right;">1,690</td>
<td style="text-align: right;">1,460</td>
</tr>
<tr class="even">
<td style="text-align: right;">8</td>
<td style="text-align: right;">2,590</td>
<td style="text-align: right;">2,330</td>
<td style="text-align: right;">2,110</td>
<td style="text-align: right;">1,990</td>
<td style="text-align: right;">1,890</td>
<td style="text-align: right;">1,660</td>
</tr>
<tr class="odd">
<td style="text-align: right;">9</td>
<td style="text-align: right;">2,820</td>
<td style="text-align: right;">2,550</td>
<td style="text-align: right;">2,320</td>
<td style="text-align: right;">2,190</td>
<td style="text-align: right;">2,100</td>
<td style="text-align: right;">1,850</td>
</tr>
<tr class="even">
<td style="text-align: right;">10</td>
<td style="text-align: right;">3,050</td>
<td style="text-align: right;">2,760</td>
<td style="text-align: right;">2,540</td>
<td style="text-align: right;">2,400</td>
<td style="text-align: right;">2,290</td>
<td style="text-align: right;">2,030</td>
</tr>
<tr class="odd">
<td style="text-align: right;">11</td>
<td style="text-align: right;">3,270</td>
<td style="text-align: right;">2,990</td>
<td style="text-align: right;">2,750</td>
<td style="text-align: right;">2,600</td>
<td style="text-align: right;">2,490</td>
<td style="text-align: right;">2,220</td>
</tr>
<tr class="even">
<td style="text-align: right;">12</td>
<td style="text-align: right;">3,510</td>
<td style="text-align: right;">3,180</td>
<td style="text-align: right;">2,960</td>
<td style="text-align: right;">2,810</td>
<td style="text-align: right;">2,690</td>
<td style="text-align: right;">2,410</td>
</tr>
<tr class="odd">
<td style="text-align: right;">13</td>
<td style="text-align: right;">3,690</td>
<td style="text-align: right;">3,390</td>
<td style="text-align: right;">3,150</td>
<td style="text-align: right;">3,000</td>
<td style="text-align: right;">2,890</td>
<td style="text-align: right;">2,590</td>
</tr>
<tr class="even">
<td style="text-align: right;">14</td>
<td style="text-align: right;">3,900</td>
<td style="text-align: right;">3,600</td>
<td style="text-align: right;">3,340</td>
<td style="text-align: right;">3,190</td>
<td style="text-align: right;">3,080</td>
<td style="text-align: right;">2,770</td>
</tr>
<tr class="odd">
<td style="text-align: right;">15</td>
<td style="text-align: right;">4,070</td>
<td style="text-align: right;">3,810</td>
<td style="text-align: right;">3,540</td>
<td style="text-align: right;">3,380</td>
<td style="text-align: right;">3,260</td>
<td style="text-align: right;">2,950</td>
</tr>
<tr class="even">
<td style="text-align: right;">16</td>
<td style="text-align: right;">4,300</td>
<td style="text-align: right;">4,010</td>
<td style="text-align: right;">3,750</td>
<td style="text-align: right;">3,580</td>
<td style="text-align: right;">3,460</td>
<td style="text-align: right;">3,140</td>
</tr>
<tr class="odd">
<td style="text-align: right;">17</td>
<td style="text-align: right;">4,510</td>
<td style="text-align: right;">4,210</td>
<td style="text-align: right;">3,950</td>
<td style="text-align: right;">3,770</td>
<td style="text-align: right;">3,640</td>
<td style="text-align: right;">3,320</td>
</tr>
<tr class="even">
<td style="text-align: right;">18</td>
<td style="text-align: right;">4,730</td>
<td style="text-align: right;">4,400</td>
<td style="text-align: right;">4,140</td>
<td style="text-align: right;">3,960</td>
<td style="text-align: right;">3,830</td>
<td style="text-align: right;">3,500</td>
</tr>
<tr class="odd">
<td style="text-align: right;">19</td>
<td style="text-align: right;">4,920</td>
<td style="text-align: right;">4,600</td>
<td style="text-align: right;">4,330</td>
<td style="text-align: right;">4,160</td>
<td style="text-align: right;">4,030</td>
<td style="text-align: right;">3,690</td>
</tr>
<tr class="even">
<td style="text-align: right;">20</td>
<td style="text-align: right;">5,130</td>
<td style="text-align: right;">4,790</td>
<td style="text-align: right;">4,520</td>
<td style="text-align: right;">4,360</td>
<td style="text-align: right;">4,220</td>
<td style="text-align: right;">3,860</td>
</tr>
</tbody>
</table>
</div>
</div>
<p>Source : <span class="citation" data-cites="hansen1990lagrange">Hansen (<a href="#ref-hansen1990lagrange" role="doc-biblioref">1990</a>)</span>.</p>
</div>
</figure>
</div>
<p>Ce test est implémenté dans la fonction <code>tvCoef::hansen_test()</code>. Par défaut, le test joint ne comprend pas le test de constance de la variance (<code>sigma = FALSE</code>).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">hansen_test</span>(reg_lin)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                   L Stat Reject at 5%
(Intercept)   1.7847 0.47         TRUE
bc_fr_m1      1.8040 0.47         TRUE
diff_bc_fr_m1 0.1883 0.47        FALSE
Variance      0.1169 0.47        FALSE
Joint Lc      2.0730 1.47         TRUE</code></pre>
</div>
</div>
<p>Sur notre modèle de prévision de la croissance, le test de Hansen conclut à la non-constance des coefficients associés à la constance et au climat des affaires en niveau au seuil de 5 %. En revanche, le coefficient associé au climat des affaires en différences serait constant (au seuil de 5 %).</p>
<p>Le test de Hansen peut être vu comme une extension des tests de stabilité CUSUM (<em>cumulative sum control chart</em>) et CUSUM sur les carrés (pour le test sur la variance). Il est robuste à l’hétéroscédasticité. En appliquant les mêmes formules au modèle “transformé”, ce test est également robuste à la prise en compte de l’autocorrélation via les moindres carrés généralisés. En revanche, ce test suppose que toutes les variables sont stationnaires : il ne peut donc directement s’appliquer sur des modèles du type modèle à correction d’erreur. Dans ce cas, une loi asymptotique différente doit être utilisée<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>. Si le modèle est estimé en deux étapes par la méthode de <span class="citation" data-cites="engle1987co">Engle et Granger (<a href="#ref-engle1987co" role="doc-biblioref">1987</a>)</span>, le test peut en revanche s’appliquer sur la seconde estimation (estimation des paramètres de court-terme).</p>
</section>
</section>
<section id="sec-desc-meth" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Descriptions des méthodes</h1>
<p>Si un des tests précédents conclut à la non constance des coefficients du modèle estimé c’est qu’il est mal spécifié et donc qu’il faut utiliser une modélisation alternative qui pourrait notamment provenir d’un problème de variables omises. Dans cet article, nous supposons que le problème de spécification provient des observations récentes et qu’il n’est pas nécessaire de faire un ajout de nouvelles variables explicatives pour le régler. Dans certains cas, par exemple pour prendre en compte la crise du COVID-19, il peut être utile nécessaires d’ajouter des variables supplémentaires (e.g., des indicatrices).</p>
<p>Trois méthodes sont étudiées dans cet article :</p>
<ul>
<li><p>la régression linéaire par morceaux (<a href="#sec-reg-morceaux" class="quarto-xref">section&nbsp;3.1</a>) ;</p></li>
<li><p>la régression locale (<a href="#sec-reg-locale" class="quarto-xref">section&nbsp;3.2</a>) ;</p></li>
<li><p>les modèles espace-état (<a href="#sec-ssm" class="quarto-xref">section&nbsp;3.3</a>).</p></li>
</ul>
<section id="sec-reg-morceaux" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="sec-reg-morceaux"><span class="header-section-number">3.1</span> Régression par morceaux</h2>
<p>La régression par morceaux est la modélisation la plus simple : elle consiste à estimer le modèle sur un sous-ensemble des données. La modélisation est similaire à celle de la procédure de Bai et Perron puisque cette dernière donne directement les “morceaux” : entre les dates de ruptures.</p>
<p>Par exemple, pour le modèle de prévision de la croissance, deux régressions seraient estimés en utilisant les données avant et après 2000T2.</p>
<p>Deux méthodes d’estimations sont possibles :</p>
<ol type="1">
<li><p>Une régression en une étape est faite en doublant découpant les régresseurs en fonction de la date de rupture (fonction <code>tvCoef::piece_reg()</code>) : <span class="math display">\[\begin{align*}
\% PIB_t &amp;= \alpha_0\1_{t\leq 2000T2} + \alpha_1 climat\_fr_t\1_{t\leq 2000T2} + \alpha_2 \Delta climat\_fr_t\1_{t\leq 2000T2} + \\
&amp;\phantom{=} \alpha_0'\1_{t &gt; 2000T2} + \alpha_1' climat\_fr_t\1_{t &gt; 2000T2} + \alpha_2' \Delta climat\_fr_t\1_{t &gt; 2000T2} + \varepsilon_t
\end{align*}\]</span> <!-- ```{r} --> <!-- #| echo: false --> <!-- #| output: asis --> <!-- date_rupture <- format(zoo::as.yearqtr(strucchange::breakdates(bp)), "%YT%q") --> <!-- cat( --> <!--   sprintf(" --> <!-- \\begin{align*} --> <!-- \\%% PIB_t &= \\alpha_0\\1_{t\\leq %s} + \\alpha_1 climat\\_fr_t\\1_{t\\leq %s} + \\alpha_2 \\Delta climat\\_fr_t\\1_{t\\leq %s} + \\\\ --> <!-- &\\phantom{=} \\alpha_0'\\1_{t > %s} + \\alpha_1' climat\\_fr_t\\1_{t > %s} + \\alpha_2' \\Delta climat\\_fr_t\\1_{t > %s} + \\varepsilon_t --> <!-- \\end{align*} --> <!--           ",date_rupture,date_rupture,date_rupture,date_rupture,date_rupture,date_rupture --> <!--   ) --> <!-- ) --> <!-- ``` --></p></li>
<li><p>En effectuant deux régressions linéaires distinctes (fonction <code>tvCoef::bp_lm()</code>) : <span class="math display">\[
\begin{cases}
\forall t \leq 2000T2 :\quad \% PIB_t = \alpha_0 + \alpha_1 climat\_fr_t + \alpha_2 \Delta climat\_fr_t + \varepsilon_t \\
\forall t &gt; 2000T2 :\quad \% PIB_t = \alpha_0' + \alpha_1' climat\_fr_t + \alpha_2' \Delta climat\_fr_t + \varepsilon_t'
\end{cases}.
\]</span> <!-- ```{r} --> <!-- #| echo: false --> <!-- #| output: asis --> <!-- cat( --> <!--   sprintf("$$ --> <!-- \\begin{cases} --> <!-- \\forall t \\leq %s :\\quad \\%% PIB_t = \\alpha_0 + \\alpha_1 climat\\_fr_t + \\alpha_2 \\Delta climat\\_fr_t + \\varepsilon_t \\\\ --> <!-- \\forall t > %s :\\quad \\%% PIB_t = \\alpha_0' + \\alpha_1' climat\\_fr_t + \\alpha_2' \\Delta climat\\_fr_t + \\varepsilon_t' --> <!-- \\end{cases}. --> <!-- $$          ",date_rupture,date_rupture --> <!--   ) --> <!-- ) --> <!-- ``` --></p></li>
</ol>
<p>Dans les deux cas les coefficients estimés sont les mêmes mais les écarts-types seront en général différents. En effet, dans la première modélisation on suppose que la variance du résidu est constante dans les deux sous-périodes alors que dans la seconde on autorise la variance à évoluer dans le temps.</p>
<p>Dans la majorité des cas, nous suggérons de privilégier la première modélisation car elle offre plus de flexibilité, notamment pour fixer les coefficients de certaines variables.</p>
<p>Dans notre exemple, les coefficients associés à la constante et au climat des affaires en niveau sont proches avant et après la rupture, ce qui est cohérent avec le résultat du test de Hansen (<a href="#sec-hansen-test" class="quarto-xref">section&nbsp;2.2</a>) :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>reg_morc <span class="ot">&lt;-</span> <span class="fu">piece_reg</span>(reg_lin)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="fu">coef</span>(reg_morc<span class="sc">$</span>model)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>`(Intercept)_2000.25`      bc_fr_m1_2000.25 diff_bc_fr_m1_2000.25 
          -1.73593533            0.02312509            0.03091897 
`(Intercept)_2019.75`      bc_fr_m1_2019.75 diff_bc_fr_m1_2019.75 
          -1.72345409            0.02037620            0.05243651 </code></pre>
</div>
</div>
<p>Cette égalité peut être testée en utilisant un test de Fisher, par exemple avec la fonction <code>car::linearHypothesis()</code> <span class="citation" data-cites="car">(<a href="#ref-car" role="doc-biblioref">Fox et Weisberg 2019</a>)</span>. Dans notre exemple, on ne rejette pas l’hypothèse nulle d’égalité des coefficients de la constante et du climat des affaires en niveau avant et après la rupture, modèle peut donc être simplifié. Par ailleurs, on rejette l’hypothèse nulle d’égalité du coefficient associé au climat des affaires en différence : la prise en compte de la rupture est donc justifiée. Toutefois, nous conseillons de toujours considérer que la constante varie dans le temps, même lorsque que ce n’est statistiquement pas significatif&nbsp;: cela permet de s’assurer que le modèle ne sera pas biaisé par des résidus qui ne seraient pas de moyenne nulle.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>car<span class="sc">::</span><span class="fu">linearHypothesis</span>(</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  reg_morc<span class="sc">$</span>model,</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">c</span>(<span class="st">"`(Intercept)_2000.25` = `(Intercept)_2019.75`"</span>,</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">"bc_fr_m1_2000.25 = bc_fr_m1_2019.75"</span>),</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">test =</span> <span class="st">"F"</span>)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Linear hypothesis test

Hypothesis:
(Intercept)_2000.25` - Intercept)_2019.75` = 0
bc_fr_m1_2000.25 - bc_fr_m1_2019.75 = 0

Model 1: restricted model
Model 2: y ~ 0 + (`(Intercept)_2000.25` + bc_fr_m1_2000.25 + diff_bc_fr_m1_2000.25 + 
    `(Intercept)_2019.75` + bc_fr_m1_2019.75 + diff_bc_fr_m1_2019.75)

  Res.Df    RSS Df Sum of Sq      F    Pr(&gt;F)    
1    156 21.860                                  
2    154 19.096  2    2.7648 11.149 3.008e-05 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</code></pre>
</div>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>reg_morc2 <span class="ot">&lt;-</span> <span class="fu">piece_reg</span>(reg_lin, <span class="at">fixed_var =</span> <span class="dv">2</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>car<span class="sc">::</span><span class="fu">linearHypothesis</span>(</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  reg_morc2<span class="sc">$</span>model,</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">c</span>(<span class="st">"diff_bc_fr_m1_2000.25 = diff_bc_fr_m1_2019.75"</span>),</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">test =</span> <span class="st">"F"</span>)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Linear hypothesis test

Hypothesis:
diff_bc_fr_m1_2000.25 - diff_bc_fr_m1_2019.75 = 0

Model 1: restricted model
Model 2: y ~ 0 + (`(Intercept)_2000.25` + `(Intercept)_2019.75` + bc_fr_m1 + 
    diff_bc_fr_m1_2000.25 + diff_bc_fr_m1_2019.75)

  Res.Df    RSS Df Sum of Sq      F Pr(&gt;F)
1    156 19.411                           
2    155 19.123  1   0.28806 2.3349 0.1285</code></pre>
</div>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">coef</span>(reg_morc2<span class="sc">$</span>model)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>`(Intercept)_2000.25` `(Intercept)_2019.75`              bc_fr_m1 
          -1.62320453           -1.88573662            0.02198848 
diff_bc_fr_m1_2000.25 diff_bc_fr_m1_2019.75 
           0.03152101            0.05174010 </code></pre>
</div>
</div>
<p>La qualité prédictive du nouveau modèle peut s’apprécier de plusieurs façons, les plus classiques étant la minimisation du critère d’information d’Akaike (AIC et fonction <code>AIC()</code>) ou la minimisation des erreurs de prévisions hors échantillon (également appelées pseudo temps-réel, fonction <code>tvCoef::oos_prev()</code>). Pour le calcul des erreurs de prévisions hors échantillon, la méthodologie retenue consiste à calculer pour chaque date <span class="math inline">\(t\)</span> la prévision obtenue à la date <span class="math inline">\(t+1\)</span> en estimant le modèle à partir des observations disponibles jusqu’à la date <span class="math inline">\(t\)</span> uniquement. Avec cette méthode, appelée le <em>leave-one-out cross-validation</em>, on ne s’intéresse donc qu’à la qualité de prévision à l’horizon d’un trimestre (ce qui est le cas d’utilisation pour les modèles étudiés). Par ailleurs, minimiser l’AIC est asymptotiquement équivalent à minimiser ces erreurs de prévisions hors échantillon <span class="citation" data-cites="AIC">(<a href="#ref-AIC" role="doc-biblioref">Anderson et Burnham 2006</a>)</span>.</p>
<p>Sur notre exemple, la régression linéaire par morceaux permet de minimiser ces deux critères&nbsp;:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># AIC minimisé :</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="fu">AIC</span>(reg_morc<span class="sc">$</span>model) <span class="sc">&lt;</span> <span class="fu">AIC</span>(reg_lin)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] TRUE</code></pre>
</div>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>oos_reg_morc <span class="ot">&lt;-</span> <span class="fu">oos_prev</span>(reg_morc)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>oos_lm <span class="ot">&lt;-</span> <span class="fu">oos_prev</span>(reg_lin)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>res <span class="ot">&lt;-</span> <span class="fu">ts.union</span>(oos_reg_morc<span class="sc">$</span>residuals, oos_lm<span class="sc">$</span>residuals)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Les deux modèles étant équivalents avant la rupture,</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="co"># on n'étudie les prévisions qu'après celle-ci</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>res <span class="ot">&lt;-</span> <span class="fu">window</span>(res, <span class="at">start =</span> <span class="dv">2003</span>)  </span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Erreurs de prévisions hors échantillon minimisées</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="fu">apply</span>(res, <span class="dv">2</span>, rmse)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>oos_reg_morc$residuals       oos_lm$residuals 
             0.3909225              0.4192182 </code></pre>
</div>
</div>
<p>La <a href="#fig-prev-piecereg" class="quarto-xref">figure&nbsp;1</a> montre les prévisions hors échantillon des deux modèles étudiés. Autour de la date de rupture, la régression linéaire par morceaux produit des prévisions peu réalistes : cela s’explique par le fait que très peu d’observations sont utilisées pour estimer les coefficients associés aux régresseurs après la rupture, les estimateurs sont donc peu précis (grande variance). Pour les analyses hors échantillon, il faut donc faire attention aux valeurs prédites autour de la rupture !</p>
<div class="cell">
<div class="cell-output cell-output-stderr">
<pre><code>Scale for x is already present.
Adding another scale for x, which will replace the existing scale.</code></pre>
</div>
<div class="cell-output-display">
<div id="fig-prev-piecereg" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-fig" id="fig-prev-piecereg-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1- Prévision de la croissance du PIB à partir d’un modèle de régression linéaire et d’un modèle de régression linéaire par morceaux.
</figcaption>
<div aria-describedby="fig-prev-piecereg-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="DT-tvcoef_files/figure-html/fig-prev-piecereg-1.png" class="img-fluid figure-img" width="672">
</div>
</figure>
</div>
</div>
</div>
<p>Comme indiqué dans la <a href="#sec-test-baiperron" class="quarto-xref">section&nbsp;2.1</a>, l’inconvénient de cette méthode provient du choix de la date de rupture lorsque celle-ci n’est pas imposée par l’utilisateur. La <a href="#fig-temps-reel-bp" class="quarto-xref">figure&nbsp;2</a> montre les dates de la rupture détectée par la procédure de Bai et Perron en fonction de la date de fin de fin d’estimation du modèle de régression linéaire : aucune rupture n’est détectée avant 2009 ou lorsque le modèle est estimé en utilisant des données jusqu’en 2013T2-2015T3. En fonction de la date de fin d’estimation, la rupture détectée automatiquement peut tout aussi bien être en 2000 qu’en 2004 ou 2006. Même s’il est possible que cela n’ait que très peu d’effet sur les prévisions estimées en fin de période, l’interprétation faite du modèle sera vraisemblablement différente !</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-temps-reel-bp" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-fig" id="fig-temps-reel-bp-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2- Date de rupture détectée par l’algorithme de Bai et Perron en fonction de la date de fin d’estimation du modèle.
</figcaption>
<div aria-describedby="fig-temps-reel-bp-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="DT-tvcoef_files/figure-html/fig-temps-reel-bp-1.png" class="img-fluid figure-img" width="672">
</div>
</figure>
</div>
</div>
</div>
</section>
<section id="sec-reg-locale" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="sec-reg-locale"><span class="header-section-number">3.2</span> De la régression mobile à la régression locale</h2>
<p>La régression mobile est une des méthodes empiriques les plus simples pour savoir si les coefficients évoluent dans le temps. Celle-ci consiste à estimer des régression en utilisant un intervalle de temps fixe et à observer la courbe des coefficients estimés. En reprenant notre exemple où les données commencent en 1980, avec une fenêtre fixe de 15 ans (par exemple), cela consiste à estimer une première régression entre 1980T1 et 1994T4, une deuxième entre 1980T2 et 1995T1… et une dernière entre 2005T1 et 2019T4. Sous R cela peut par exemple s’estimer en utilisant la fonction <code>roll::roll_lm()</code> <span class="citation" data-cites="roll">(<a href="#ref-roll" role="doc-biblioref">Foster 2020</a>)</span> :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>roll_lm <span class="ot">&lt;-</span> roll<span class="sc">::</span><span class="fu">roll_lm</span>(</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">x =</span> data_gdp[, <span class="fu">c</span>(<span class="st">"bc_fr_m1"</span>, <span class="st">"diff_bc_fr_m1"</span>)],</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">y =</span> data_gdp[, <span class="st">"growth_gdp"</span>],</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">width =</span> <span class="dv">4</span> <span class="sc">*</span> <span class="dv">15</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>coef_roll_lm <span class="ot">&lt;-</span> <span class="fu">ts</span>(roll_lm<span class="sc">$</span>coefficients, <span class="at">start =</span> <span class="dv">1980</span>, <span class="at">frequency =</span> <span class="dv">4</span>)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La <a href="#fig-coef-rollreg" class="quarto-xref">figure&nbsp;3</a> montre les coefficients estimés par cette régression mobile. Seule ceux estimés sur le climat des affaires en différence montrent une rupture nette. Elle s’observe à partir de 2009, lorsque plus de la moitié des points de la fenêtre (7,5 ans) sont estimés après la date de rupture détectée (2000T2).</p>
<div id="fig-coef-rollreg" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-fig" id="fig-coef-rollreg-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3- Coefficients estimés par régression mobile et régression par morceaux.
</figcaption>
<div aria-describedby="fig-coef-rollreg-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="DT-tvcoef_files/figure-html/ffig-coef-rollreg-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Lecture : la régression mobile est estimée sur une fenêtre de 15 ans. Les coefficients estimés en 1994T4 correspondent aux coefficients estimés entre 1980T1 et 1994T4.</p>
</div>
</figure>
</div>
<p>La régression mobile a l’avantage d’être très simple mais repose sur plusieurs paramètres qui ont ici été fixés arbitrairement dont notamment :</p>
<ul>
<li><p>La longueur de la fenêtre : elle doit être suffisamment large pour avoir des bonnes estimations mais suffisamment courte afin de permettre de prendre en compte les ruptures.</p></li>
<li><p>La date à laquelle les coefficients sont associés. Dans la fonction <code>roll::roll_lm()</code> ils sont associés à la dernière date de la fenêtre : les coefficients de la date <span class="math inline">\(t\)</span> correspondent à ceux obtenus en utilisant les données jusqu’à la date <span class="math inline">\(t.\)</span> Ils auraient également pu être associés à la première date de la fenêtre ou encore à son milieu (coefficients de la date <span class="math inline">\(t\)</span> estimés en utilisant autant d’observations avant et après <span class="math inline">\(t\)</span>). Dans tous les cas une stratégie doit être adoptée afin de gérer les observations manquantes (dans notre exemple il s’agit donc d’estimer les coefficients avant 1994).</p></li>
</ul>
<p>La régression locale permet, grâce à une modélisation plus poussée, de donner des solutions à ce problème. Dans ce papier nous détaillons la modélisation utilisée dans la fonction <code>tvReg::tvLM()</code> développée par <span class="citation" data-cites="tvReg">Casas et Fernandez-Casal (<a href="#ref-tvReg" role="doc-biblioref">2019</a>)</span><a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>. On suppose ici que les coefficients <span class="math inline">\(\bf\alpha_t\)</span> dépendent d’une variable aléatoire <span class="math inline">\(z_t\)</span> : <span class="math inline">\(\bf\alpha_t=\alpha(z_t).\)</span> Par défaut <span class="math inline">\(z_t=t/T\)</span> avec <span class="math inline">\(T\)</span> le nombre d’observations : les coefficients dépendent donc d’une mesure normalisée du temps. On suppose que la fonction <span class="math inline">\(\alpha\)</span> est localement constante (<span class="math inline">\(\alpha(z_t)\simeq \alpha(z)\)</span>, option par défaut) ou localement linéaire (<span class="math inline">\(\alpha(z_t)\simeq \alpha(z)+\alpha'(z)(z_t-z)\)</span>), c’est-à-dire que pour toute date <span class="math inline">\(t\)</span> on a pour toute date <span class="math inline">\(i\)</span> proche de <span class="math inline">\(t\)</span> : <span class="math inline">\(\alpha(z_i)\simeq\alpha(z_t)\)</span> ou <span class="math inline">\(\alpha(z_i)\simeq\alpha(z_t)+\alpha'(z_t)(z_i-z_t).\)</span> Cette approximation locale est justifiée par le théorème de Taylor.</p>
<p>Pour chaque date <span class="math inline">\(t\)</span>, le coefficient <span class="math inline">\(\alpha_t=\alpha(z_t)\)</span> est obtenu par moindres carrés pondérés. Lorsque <span class="math inline">\(\alpha\)</span> est supposé localement constant il s’agit du système : <span class="math display">\[
\hat{\bf\alpha_t}=\hat{\alpha}(z_t)=\underset{\bf\theta_0}\argmin\sum_{i=1}^T\left[y_i-{\bf X_i}\bf\theta_0 \right]^2K_{b_t}(z_i-z_t).
\]</span> Lorsque <span class="math inline">\(\alpha\)</span> est supposé localement linéaire il s’agit du système : <span class="math display">\[
(\hat{\alpha}(z_t), \hat{\alpha}'(z_t))=\underset{\bf \theta_0,\bf \theta_1}\argmin\sum_{i=1}^T\left[y_i-{\bf X_i}\bf\theta_0 - (z_i-z_t){\bf X_i}\bf\theta_1\right]^2K_{b_t}(z_i-z_t).
\]</span> Avec <span class="math inline">\(K_{b_t}(z_i-z_t)=\frac{1}{b_t}K\left(\frac{z_i-z_t}{b_t}\right)\)</span> et <span class="math inline">\(K(\cdot)\)</span> une fonction de noyau. La fonction <span class="math inline">\(K\)</span> permet de pondérer les observations : pour l’estimation du coefficient à la date <span class="math inline">\(t\)</span> on accorde généralement plus d’importance (i.e., un poids plus important) aux observations qui sont proches de <span class="math inline">\(t\)</span> qu’à celles qui sont éloignées de <span class="math inline">\(t.\)</span> C’est une fonction positive, paire et intégrable telle que <span class="math inline">\(\int_{-\infty}^{+\infty}K(u) \ud u=1.\)</span> Trois noyaux sont disponibles dans la fonction <code>tvReg::tvLM()</code> :</p>
<ul>
<li><p>Le cubique (<em>triweight</em>, utilisé par défaut) : <span class="math display">\[
K(u)=\frac{35}{32}\left(
1-
\left\lvert
u
\right\lvert^2
\right)^3\1_{[-1,1]}(u).
\]</span></p></li>
<li><p>Le noyau d’Epanechnikov (ou parabolique) : <span class="math display">\[
K(u)=\frac{3}{4}\left(
1-
\left\lvert
u
\right\lvert^2
\right)\1_{[-1,1]}(u).
\]</span></p></li>
<li><p>Le noyau Gaussien : <span class="math display">\[
K(u)=\frac{1}{\sqrt{2\pi}}\exp\left(-\frac{1}{2}u^2\right).
\]</span></p></li>
</ul>
<p>Le paramètre <span class="math inline">\(b_t\)</span> permet de calibrer la largeur de la fenêtre (i.e., le nombre de points utilisés pour chaque estimation). Il est généralement supposé constant (<span class="math inline">\(b_t=b\)</span>).</p>
<p>Dans notre exemple de prévision du PIB, <span class="math inline">\(T=160\)</span> observations sont utilisées. Avec <span class="math inline">\(z_t=t/T\)</span> et indexant chaque observation entre 1 et <span class="math inline">\(T,\)</span> la régression mobile sur 15 ans où l’on affecte le coefficient de la date <span class="math inline">\(t\)</span> au milieu de la fenêtre d’estimation est donc retrouvée en utilisant le noyau uniforme <span class="math inline">\(K(u)=\1_{[-1,1]}(x)\)</span> avec <span class="math inline">\(b_t=b=\frac{30}{160}.\)</span> En effet, dans ce cas <span class="math inline">\(K(z_t-z_i)\ne0\)</span> si et seulement si <span class="math inline">\(|t-i|\leq30\)</span> : on utilise donc 30 observations (soit <span class="math inline">\(7,5\)</span> ans) autour de <span class="math inline">\(t\)</span> pour estimer le coefficient à la date <span class="math inline">\(t.\)</span></p>
<p>Dans <code>tvReg</code>, le paramètre <span class="math inline">\(b\)</span> est par défaut obtenu en minimisant une statistique de validation croisée dans l’intervalle <span class="math inline">\(\left[\frac{5}{T},20\right].\)</span> Lorsque <span class="math inline">\(b\)</span> est plus grand que 1, toutes les observations sont utilisées pour l’estimation de chaque coefficient <span class="math inline">\(\bf\alpha_t.\)</span> Plus <span class="math inline">\(b\)</span> se rapproche de 1 plus on se rapproche du cas de la régression linéaire puisque dans ce cas les poids donnés par <span class="math inline">\(K\)</span> tendent à être constants pour toutes les observations. En effet, dans ce cas, pour <span class="math inline">\(T=160,\)</span> <span class="math inline">\(\frac{\max_u K(u)}{\min_u K(u)}\)</span> est compris entre <span class="math inline">\(1,001\)</span> et <span class="math inline">\(1,008\)</span> pour les noyaux cubiques, paraboliques et gaussiens.</p>
<p>Reprenons notre exemple de prévision du PIB avec une détection automatique de la fenêtre.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>reg_loc <span class="ot">&lt;-</span> tvReg<span class="sc">::</span><span class="fu">tvLM</span>(</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">formula =</span> growth_gdp <span class="sc">~</span> bc_fr_m1 <span class="sc">+</span> diff_bc_fr_m1,</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">data =</span> data_gdp</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Calculating regression bandwidth... bw =  0.7485784 </code></pre>
</div>
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(reg_loc)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call: 
tvReg::tvLM(formula = growth_gdp ~ bc_fr_m1 + diff_bc_fr_m1, 
    data = data_gdp)

Class:  tvlm 

Summary of time-varying estimated coefficients: 
================================================ 
        (Intercept) bc_fr_m1 diff_bc_fr_m1
Min.         -1.924  0.02037       0.03429
1st Qu.      -1.886  0.02145       0.03930
Median       -1.800  0.02233       0.04470
Mean         -1.773  0.02222       0.04342
3rd Qu.      -1.680  0.02308       0.04777
Max.         -1.503  0.02338       0.04927

Bandwidth:  0.7486
Pseudo R-squared:  0.4549 </code></pre>
</div>
</div>
<p>La fenêtre estimée par défaut est de 0,75, c’est-à-dire que pour estimer le coefficient à la date <span class="math inline">\(t\)</span> on utilise au plus 30 ans avant et après <span class="math inline">\(t\)</span> : on utilise tous les points dans la majorité des cas. Cela explique le caractère très lisse des coefficients (<a href="#fig-coef-reg-mobile" class="quarto-xref">figure&nbsp;4</a>). Avec ce paramètre pour la fenêtre, les ruptures brutales sont donc difficiles à prendre en compte.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-coef-reg-mobile" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-fig" id="fig-coef-reg-mobile-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4- Coefficients estimés par régression linéaire, régression par morceaux et régression locale (avec <span class="math inline">\(b=0,74\)</span>).
</figcaption>
<div aria-describedby="fig-coef-reg-mobile-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="DT-tvcoef_files/figure-html/fig-coef-reg-mobile-1.png" class="img-fluid figure-img" width="672">
</div>
</figure>
</div>
</div>
</div>
<p>Un des inconvénients de méthode de sélection automatique de la fenêtre est que la statistique de validation croisée est un critère peu discriminant (voir <span class="citation" data-cites="Loader1999">Clive Loader (<a href="#ref-Loader1999" role="doc-biblioref">1999</a>)</span>) : il peut y avoir très peu de différences entre différentes valeurs de la fenêtre alors que celle-ci a un impact fort sur l’interprétation du modèle ! Cela a également pour effet que la méthode est peu stable dans le temps (<a href="#fig-oos-bw" class="quarto-xref">figure&nbsp;5</a>), ce qui augmente les sources de révisions des simulations hors échantillon, calculables en utilisant la fonction <code>oos_prev()</code> :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>oos_reg_loc <span class="ot">&lt;-</span> <span class="fu">oos_prev</span>(reg_loc)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>oos_bw <span class="ot">&lt;-</span> <span class="fu">ts</span>(<span class="fu">sapply</span>(oos_reg_loc<span class="sc">$</span>model, <span class="st">`</span><span class="at">[[</span><span class="st">`</span>,<span class="st">"bw"</span>),</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>             <span class="at">end =</span> <span class="fu">c</span>(<span class="dv">2019</span>, <span class="dv">4</span>),</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>             <span class="at">frequency =</span> <span class="dv">4</span>)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="cell-output cell-output-stderr">
<pre><code>Scale for x is already present.
Adding another scale for x, which will replace the existing scale.</code></pre>
</div>
<div class="cell-output-display">
<div id="fig-oos-bw" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-fig" id="fig-oos-bw-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;5- Fenêtre <span class="math inline">\(b\)</span> détectée automatiquement en fonction de la date de fin d’estimation du modèle.
</figcaption>
<div aria-describedby="fig-oos-bw-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="DT-tvcoef_files/figure-html/fig-oos-bw-1.png" class="img-fluid figure-img" width="672">
</div>
</figure>
</div>
</div>
</div>
<p>Pour l’estimation hors échantillon, la méthode utilisée est l’utilisation d’une fonction de noyau tronquée : plus de points dans le passé que dans le futur sont utilisés pour estimer les derniers coefficients. C’est donc également une source de révision au fur et à mesure que des nouveaux points seront connus. Même si des méthodes optimales existent pour minimiser les erreurs d’estimation des coefficients hors échantillon (voir par exemple <span class="citation" data-cites="FengSchafer2021">Feng et Schäfer (<a href="#ref-FengSchafer2021" role="doc-biblioref">2021</a>)</span>), cela devrait ici avoir peu d’impact car un modèle très simple est ici utilisé pour estimer les coefficients (approximation de la fonction <span class="math inline">\(\alpha\)</span> par une constante).</p>
<p>Un autre inconvénient de ces méthodes est que tous les coefficients varient dans la temps alors que dans certains cas on peut supposer la relation constante. Si l’on souhaite fixer certains coefficients, on peut procéder comme dans la <a href="#sec-test-baiperron" class="quarto-xref">section&nbsp;2.1</a> en faisant une régression linéaire, pour estimer les coefficients fixes, suivie d’une régression mobile.</p>
</section>
<section id="sec-ssm" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="sec-ssm"><span class="header-section-number">3.3</span> Modélisation espace-état</h2>
<p>La modélisation espace-état est une méthodologie générale permettant de traiter un grand nombre de problèmes de séries temporelles. Dans cette approche, on suppose que tout modèle est déterminé par une série de vecteurs non observés <span class="math inline">\(\alpha_1,\dots,\alpha_n\)</span> associés aux observations <span class="math inline">\(y_1,\dots,y_n\)</span>, la relation entre <span class="math inline">\(\alpha_t\)</span> et <span class="math inline">\(y_t\)</span> étant spécifiée par le modèle espace-état. Ces modèles sont largement décrits dans la littérature, notamment par <span class="citation" data-cites="durbinkoopman">Durbin et Koopman (<a href="#ref-durbinkoopman" role="doc-biblioref">2012</a>)</span>. Dans cet article, nous nous placerons dans un cadre simplifié des modèles linéaires gaussiens appliqués aux régressions linéaires. Les modèles sont déterminés par un ensemble de deux équations : <span class="math display">\[
\begin{cases}
y_t={\bf X_t}\bf\alpha_t+\varepsilon_t,\quad&amp;\varepsilon_t\sim\mathcal N(0,\sigma^2)\\
\bf\alpha_{t+1}=\bf\alpha_t+\bf\eta_t,\quad&amp;\bf\eta_t\sim\mathcal N(\bf 0,\bf\Sigma)
\end{cases},\text{ avec }\eta_t\text{ et }\varepsilon_t\text{ indépendants.}
\]</span> La première équation est l’équation d’observation (<em>observation equation</em>), la seconde l’équation d’état (<em>state equation</em>) et <span class="math inline">\(\bf\alpha_t\)</span> le vecteur d’états (<em>state vector</em>).</p>
<p>Dans cette étude, la matrice de variance-covariance <span class="math inline">\(\bf\Sigma\)</span> est supposée diagonale : la dynamique d’évolution des coefficients d’une variable est donc indépendante de la dynamique d’évolution des autres variables. Lorsque des contraintes entre les différents coefficients existent, des spécifications différentes de la matrice de variance-covariance <span class="math inline">\(\bf\Sigma\)</span> peuvent être faites : c’est par exemple ce qui a été fait par <span class="citation" data-cites="abs2006">Zhang et Poskitt (<a href="#ref-abs2006" role="doc-biblioref">2006</a>)</span> pour estimer des coefficients jours ouvrables variant dans le temps. On retrouve le cas de la régression linéaire lorsque <span class="math inline">\(\bf\Sigma=\bf 0\)</span> puisque dans ce cas tous les <span class="math inline">\(\alpha_t\)</span> sont égaux.</p>
<p>Ces modèles sont implémentés dans la fonction <code>tvCoef::ssm_lm()</code> qui prend en entrée un modèle de régression linéaire. L’implémentation est basée sur le package <code>rjd3sts</code> <span class="citation" data-cites="rjd3sts">(<a href="#ref-rjd3sts" role="doc-biblioref">Palate 2023</a>)</span> qui permet d’implémenter très facilement les modèles espaces-état sans devoir écrire explicitement le modèle. Par défaut les variances du vecteur d’états (<span class="math inline">\(\bf \Sigma\)</span>) ne sont pas estimés et fixés à 0 : on retrouve donc les coefficients estimés par régression linéaire.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>ssm <span class="ot">&lt;-</span> <span class="fu">ssm_lm</span>(reg_lin)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>ssm</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Mean of time-varying estimated coefficients (smoothing): 
  (Intercept)      bc_fr_m1 diff_bc_fr_m1         noise 
      -1.6377        0.0208        0.0422        0.0000 </code></pre>
</div>
</div>
<p>L’estimation des hyperparamètres (variances des bruits blancs) est faite par maximum de vraisemblance différentes méthodes existent pour initialiser les modèles (calculer <span class="math inline">\(\bf \alpha_1\)</span>). Pour plus de détails voir par exemple <span class="citation" data-cites="durbinkoopman">Durbin et Koopman (<a href="#ref-durbinkoopman" role="doc-biblioref">2012</a>)</span>. Le filtre de Kalman permet ensuite de calculer tous les coefficients. Parmi les paramètres calculés, les deux principaux sont :</p>
<ol type="1">
<li>Les états lissés (<em>smoothed states</em>) <span class="math inline">\(\E{\alpha_t|y_1,\dots,y_n}\)</span> : il s’agit de l’estimation des états (<span class="math inline">\(\bf\alpha_t\)</span>) en utilisant toute l’information disponible. Dans le cadre de la régression linéaire, les états lissés sont donc constants sur toutes les dates et correspondent aux coefficients estimés en utilisant l’ensemble des données disponibles :</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="fu">window</span>(ssm<span class="sc">$</span>smoothed_states, <span class="at">start =</span> <span class="dv">2019</span>)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        (Intercept)   bc_fr_m1 diff_bc_fr_m1       noise
2019 Q1   -1.637698 0.02084469    0.04215106  0.23277648
2019 Q2   -1.637698 0.02084469    0.04215106  0.01219046
2019 Q3   -1.637698 0.02084469    0.04215106 -0.50526528
2019 Q4   -1.637698 0.02084469    0.04215106 -0.84723791</code></pre>
</div>
</div>
<ol start="2" type="1">
<li>Les états filtrés (<em>filtered states</em>) <span class="math inline">\(\E{\alpha_t|y_1,\dots,y_{t-1}}\)</span> : il s’agit de l’estimation des états (<span class="math inline">\(\bf\alpha_t\)</span>) en utilisant l’information disponible jusqu’à la date précédente. Dans le cadre de la régression linéaire, cela correspond aux coefficients estimés hors échantillon : la valeur des états filtrés en 2010T2 correspond aux coefficients estimés en utilisant les données jusqu’au 2010T1. Ils permettent donc d’avoir une estimation des prévisions hors échantillon du modèle.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="fu">round</span>(<span class="fu">window</span>(ssm<span class="sc">$</span>filtering_states, <span class="at">start =</span> <span class="fu">c</span>(<span class="dv">2010</span>, <span class="dv">2</span>), <span class="at">end =</span> <span class="fu">c</span>(<span class="dv">2010</span>, <span class="dv">2</span>)), <span class="dv">6</span>)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        (Intercept) bc_fr_m1 diff_bc_fr_m1 noise
2010 Q2   -1.733678 0.022248       0.04724     0</code></pre>
</div>
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="fu">round</span>(<span class="fu">coef</span>(<span class="fu">dynlm</span>(</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">formula =</span> growth_gdp <span class="sc">~</span> bc_fr_m1 <span class="sc">+</span> diff_bc_fr_m1,</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">data =</span> <span class="fu">window</span>(gdp, <span class="at">start =</span> <span class="dv">1980</span>, <span class="at">end =</span> <span class="fu">c</span>(<span class="dv">2010</span>,<span class="dv">1</span>))</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>)), <span class="dv">6</span>)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  (Intercept)      bc_fr_m1 diff_bc_fr_m1 
    -1.733678      0.022248      0.047240 </code></pre>
</div>
</div>
<p>Lorsque les variances sont estimées, les états filtrés ne correspondent pas à exactement à des estimations hors échantillon car les hyperparamètres sont fixés (variances <span class="math inline">\(\bf\Sigma\)</span> et initialisation). Les estimations hors échantillon peuvent être calculées en utilisant la fonction <code>tvCoef::ssm_lm_oos()</code>.</p>
<p>Pour faciliter l’estimation des variances <span class="math inline">\(\bf\Sigma,\)</span> le paramètre est souvent reparamétré : <span class="math display">\[
\begin{cases}
y_t={\bf X_t}\bf\alpha_t+\varepsilon_t,\quad&amp;\varepsilon_t\sim\mathcal N(0,\sigma^2)\\
\bf\alpha_{t+1}=\bf\alpha_t+\bf\eta_t,\quad&amp;\bf\eta_t\sim\mathcal N(\bf 0,\sigma^2\bf Q)
\end{cases},\text{ avec }\eta_t\text{ et }\varepsilon_t\text{ indépendants.}
\]</span> Les variances sont donc définies à un facteur multiplicatif près et une estimation en deux étapes est faite : la vraisemblance est dite <em>concentrée</em>. C’est ce qui est utilisé par défaut dans <code>tvCoef::ssm_lm()</code>. Dans notre exemple, l’erreur standard de la régression (<em>residual standar error</em>) peut se calculer de la façon suivante :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sqrt</span>(ssm<span class="sc">$</span>parameters<span class="sc">$</span>parameters <span class="sc">*</span> ssm<span class="sc">$</span>parameters<span class="sc">$</span>scaling)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>(Intercept).var       noise.var 
      0.0000000       0.3757355 </code></pre>
</div>
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(reg_lin)<span class="sc">$</span>sigma</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.3757355</code></pre>
</div>
</div>
<p>Afin d’estimer les variances associées à l’équation d’état, il faut utiliser les paramètres <code>fixed_var_intercept = FALSE</code> et <code>fixed_var_trend = FALSE</code>. Même si la valeur des variances (<code>var_intercept</code> et <code>var_variables</code> qui valent 0 par défaut) n’aura aucun effet sur les variances finales estimées, il est parfois nécessaire de modifier ces valeurs afin d’éviter une erreur dans l’optimisation. Sur notre modèle, l’optimisation conduit à garder fixe le coefficient associé au climat des affaires en niveau (variance nulle) mais considère que les autres variables varient dans le temps :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>ssm <span class="ot">&lt;-</span> <span class="fu">ssm_lm</span>(reg_lin, </span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>              <span class="at">fixed_var_intercept =</span> <span class="cn">FALSE</span>, </span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>              <span class="at">fixed_var_variables =</span> <span class="cn">FALSE</span>)</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="fu">sqrt</span>(ssm<span class="sc">$</span>parameters<span class="sc">$</span>parameters <span class="sc">*</span> ssm<span class="sc">$</span>parameters<span class="sc">$</span>scaling)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  (Intercept).var      bc_fr_m1.var diff_bc_fr_m1.var         noise.var 
      0.019564504       0.000000000       0.009305432       0.335063783 </code></pre>
</div>
</div>
<div class="proof remark">
<p><span class="proof-title"><em>Remarque</em>. </span>Dans la version actuelle de <code>tvCoef</code>, les retards de la variable endogène (à prévoir) ne sont pas modélisés correctement. En effet, dans ce cas il faudrait utiliser une modélisation différente afin de prendre en compte la relation entre la variable endogène et les retards.</p>
</div>
<p>La <a href="#fig-coef-ssm" class="quarto-xref">figure&nbsp;6</a> montre les coefficients estimés avec toutes les méthodes présentées dans ce papier. Pour toutes les méthodes, le coefficient du climat des affaires en niveau est stable dans le temps (coefficients estimés compris entre 0,020 et 0,023). En revanche, les résultats du modèle espace-état sont sensiblement différents pour le coefficient associé au climat des affaires, avec des périodes où le coefficient est plus faible que pour les autres méthodes (avant 1983, entre 1995 et 1999 et après 2011) et d’autres où il est plus élevé (notamment pendant la crise financière).</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-coef-ssm" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-fig" id="fig-coef-ssm-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;6- Coefficients estimés par régression linéaire, régression par morceaux, régression locale (avec <span class="math inline">\(b=0,74\)</span>) et modèle espace-état.
</figcaption>
<div aria-describedby="fig-coef-ssm-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="DT-tvcoef_files/figure-html/fig-coef-ssm-1.png" class="img-fluid figure-img" width="672">
</div>
</figure>
</div>
</div>
</div>
<p>La <a href="#tbl-res-model-pib" class="quarto-xref">table&nbsp;2</a> compare la qualité prédictive des différents modèles dans l’échantillon (en utilisant toutes les données et pour estimer les paramètres des modèles) et hors échantillon (reproduction du processus de prévision en estimant, de manière récursive les modèles jusqu’à la date <span class="math inline">\(t\)</span> pour calculer les prévisions à la date <span class="math inline">\(t+1\)</span>). C’est la modélisation espace-état qui minimise les erreurs de prévision, suivie de la régression par morceaux. La régression locale a une erreur hors échantillon plus élevée notamment du fait des instabilités sur l’estimation de la fenêtre. Le test de Diebold-Mariano (voir notamment <span class="citation" data-cites="DMtest">Diebold (<a href="#ref-DMtest" role="doc-biblioref">2012</a>)</span>), implémenté dans la fonction <code>forecast::dm.test()</code> <span class="citation" data-cites="forecastR">(<a href="#ref-forecastR" role="doc-biblioref">Rob J. Hyndman et Khandakar 2008</a>)</span>, permet de tester si cette différence est significative. Dans et hors échantillon, les modèles espace-état ont des erreurs de prévisions significativement plus petites que la régression linéaire (p-valeurs respectivement de 0,00 et 0,05). Dans l’échantillon elles sont également significativement plus petites que celles de la régression par morceau (p-valeur de 0,00) mais la différence n’est pas significative hors échantillon (p-valeur de 0,10) : l’interprétation économique sur les périodes récentes est en revanche différente (coefficient sur le climat des affaires en différence), ce qui conduit donc à des prévisions différentes.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>oos_ssm <span class="ot">&lt;-</span> <span class="fu">ssm_lm_oos</span>(reg_lin, <span class="at">fixed_var_intercept =</span> <span class="cn">FALSE</span>, </span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>                      <span class="at">fixed_var_variables =</span> <span class="cn">FALSE</span>,</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>                      <span class="at">date =</span> <span class="dv">70</span>)</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>res_is <span class="ot">&lt;-</span> <span class="fu">ts.union</span>(</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ts</span>(<span class="fu">residuals</span>(reg_lin), <span class="at">end =</span> <span class="fu">c</span>(<span class="dv">2019</span>,<span class="dv">4</span>), <span class="at">frequency =</span> <span class="dv">4</span>),</span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">residuals</span>(reg_morc),</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ts</span>(<span class="fu">residuals</span>(reg_loc), <span class="at">end =</span> <span class="fu">c</span>(<span class="dv">2019</span>,<span class="dv">4</span>), <span class="at">frequency =</span> <span class="dv">4</span>),</span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">residuals</span>(ssm)[,<span class="st">"smoothed"</span>]</span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>res_oos <span class="ot">&lt;-</span> <span class="fu">ts.union</span>(</span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a>  oos_lm<span class="sc">$</span>residuals,</span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a>  oos_reg_morc<span class="sc">$</span>residuals,</span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ts</span>(oos_reg_loc<span class="sc">$</span>residuals, <span class="at">end =</span> <span class="fu">c</span>(<span class="dv">2019</span>,<span class="dv">4</span>), <span class="at">frequency =</span> <span class="dv">4</span>),</span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a>  oos_ssm<span class="sc">$</span>oos_noise</span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb43-17"><a href="#cb43-17" aria-hidden="true" tabindex="-1"></a>res_oos <span class="ot">&lt;-</span> <span class="fu">window</span>(res_oos, <span class="at">start =</span> <span class="dv">2003</span>)</span>
<span id="cb43-18"><a href="#cb43-18" aria-hidden="true" tabindex="-1"></a><span class="co"># (H0) : Modèle espace-état meilleur que modèle linéaire</span></span>
<span id="cb43-19"><a href="#cb43-19" aria-hidden="true" tabindex="-1"></a>forecast<span class="sc">::</span><span class="fu">dm.test</span>(res_is[, <span class="dv">1</span>], res_is[, <span class="dv">4</span>], <span class="st">"greater"</span>)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
    Diebold-Mariano Test

data:  res_is[, 1]res_is[, 4]
DM = 3.3521, Forecast horizon = 1, Loss function power = 2, p-value =
0.0005012
alternative hypothesis: greater</code></pre>
</div>
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co"># (H0) : Modèle espace-état meilleur que régression par morceaux</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>forecast<span class="sc">::</span><span class="fu">dm.test</span>(res_is[, <span class="dv">2</span>], res_is[, <span class="dv">4</span>], <span class="st">"greater"</span>)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
    Diebold-Mariano Test

data:  res_is[, 2]res_is[, 4]
DM = 3.2101, Forecast horizon = 1, Loss function power = 2, p-value =
0.0008026
alternative hypothesis: greater</code></pre>
</div>
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="co"># (H0) : Modèle espace-état meilleur que modèle linéaire</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>forecast<span class="sc">::</span><span class="fu">dm.test</span>(res_oos[, <span class="dv">1</span>], res_oos[, <span class="dv">4</span>], <span class="st">"greater"</span>)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
    Diebold-Mariano Test

data:  res_oos[, 1]res_oos[, 4]
DM = 1.6374, Forecast horizon = 1, Loss function power = 2, p-value =
0.05312
alternative hypothesis: greater</code></pre>
</div>
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="co"># (H0) : Modèle espace-état meilleur que régression par morceaux</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>forecast<span class="sc">::</span><span class="fu">dm.test</span>(res_oos[, <span class="dv">2</span>], res_oos[, <span class="dv">4</span>], <span class="st">"greater"</span>)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
    Diebold-Mariano Test

data:  res_oos[, 2]res_oos[, 4]
DM = 1.2706, Forecast horizon = 1, Loss function power = 2, p-value =
0.1041
alternative hypothesis: greater</code></pre>
</div>
</div>
<div id="tbl-res-model-pib" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-res-model-pib-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;2- Erreurs quadratiques moyennes des erreurs de prévisions entre les différentes méthodes.
</figcaption>
<div aria-describedby="tbl-res-model-pib-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell">
<div class="cell-output-display">
<table class="table table-sm table-striped small">
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: right;">Dans l’échantillon</th>
<th style="text-align: right;">Hors échantillon</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Régression linéaire</td>
<td style="text-align: right;">0,37</td>
<td style="text-align: right;">0,42</td>
</tr>
<tr class="even">
<td style="text-align: left;">Régression par morceaux</td>
<td style="text-align: right;">0,35</td>
<td style="text-align: right;">0,39</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Régression locale</td>
<td style="text-align: right;">0,35</td>
<td style="text-align: right;">0,41</td>
</tr>
<tr class="even">
<td style="text-align: left;">Modèle espace-état</td>
<td style="text-align: right;">0,32</td>
<td style="text-align: right;">0,37</td>
</tr>
</tbody>
</table>
</div>
</div>
<p>Note : Les prévisions dans l’échantillon sont calculées en estimant les modèles à partir des données disponibles entre 1980T1 et 2019T4. Les prévisions hors échantillon sont calculées en à partir de 2003T1 : la première prévision (2003T1) correspond à celle que l’on aurait eu en estimant les modèles à partir des données disponibles jusqu’en 2002T4 (trimestre précédente).</p>
</div>
</figure>
</div>
</section>
<section id="prise-en-compte-de-la-période-du-covid-19-et-prévision" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="prise-en-compte-de-la-période-du-covid-19-et-prévision"><span class="header-section-number">3.4</span> Prise en compte de la période du COVID-19 et prévision</h2>
<p>Dans les sections précédentes, les modèles ont été estimés jusqu’en 2019T4 dans le but de simplifier la présentation des modèles. Toutefois, si l’on veut effectuer de la prévision sur les périodes récentes, il est indispensable de prendre en compte la période du COVID-19. Cela se fait généralement en ajoutant, dans le modèle de prévision, des variables explicatives modélisant les chocs de cette période. La méthode la plus simple consiste à ajouter des indicatrices sur les trimestres concernés (ici l’année 2020) :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>ind <span class="ot">&lt;-</span> <span class="fu">cbind</span>(<span class="fu">time</span>(gdp) <span class="sc">==</span> <span class="dv">2020</span>, <span class="fu">time</span>(gdp) <span class="sc">==</span> <span class="fl">2020.25</span>, </span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>             <span class="fu">time</span>(gdp) <span class="sc">==</span> <span class="fl">2020.5</span>, <span class="fu">time</span>(gdp) <span class="sc">==</span> <span class="fl">2020.75</span>)</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>ind <span class="ot">&lt;-</span> <span class="fu">ts</span>(<span class="fu">apply</span>(ind,<span class="dv">2</span>, as.numeric), <span class="at">start =</span> <span class="fu">start</span>(gdp), <span class="at">frequency =</span> <span class="dv">4</span>)</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(ind) <span class="ot">&lt;-</span> <span class="fu">sprintf</span>(<span class="st">"ind2020T%i"</span>, <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>)</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>data_covid <span class="ot">&lt;-</span> <span class="fu">ts.union</span>(gdp, ind)</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(data_covid) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fu">colnames</span>(gdp), <span class="fu">colnames</span>(ind))</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a>reg_lin_covid <span class="ot">&lt;-</span> <span class="fu">dynlm</span>(</span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a>  <span class="at">formula =</span> growth_gdp <span class="sc">~</span> bc_fr_m1 <span class="sc">+</span> diff_bc_fr_m1 <span class="sc">+</span></span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>    ind2020T1 <span class="sc">+</span> ind2020T2 <span class="sc">+</span> ind2020T3 <span class="sc">+</span> ind2020T4,</span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>  <span class="at">data =</span> <span class="fu">window</span>(data_covid, <span class="at">start =</span> <span class="dv">1980</span>)</span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a><span class="fu">coef</span>(reg_lin_covid)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  (Intercept)      bc_fr_m1 diff_bc_fr_m1     ind2020T1     ind2020T2 
  -1.62422153    0.02075517    0.05366003   -6.14116779   -9.77551672 
    ind2020T3     ind2020T4 
  15.88744163   -1.13892410 </code></pre>
</div>
</div>
<p>Pour la construction des autres modèles, nous gardons les paramètres estimés en utilisant les données avant la période du COVID-19, cette dernière pouvant biaiser les résultats. Ainsi :</p>
<ul>
<li>Pour la régression par morceaux, la date de rupture retenue est toujours 2000T2 (contre 2016T1 en utilisant les données après 2020).</li>
<li>Pour la régression locale, la fenêtre utilisée est 0,75 (contre 0,04 en utilisant les données après 2020).</li>
<li>Pour la modélisation espace-état, le coefficient du climat des affaires en niveau est toujours considéré comme fixe (il est considéré comme mobile en utilisant les données après 2020). Toutefois les variances des autres coefficients sont de nouveau estimées.</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Date différente de rupture détectée mais l'on garde 2000T2 par continuité</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>bp_covid <span class="ot">&lt;-</span> <span class="fu">breakpoints</span>(reg_lin_covid)</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="fu">c</span>(<span class="fu">breakdates</span>(bp), <span class="fu">breakdates</span>(bp_covid))</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 2000.25 2016.00</code></pre>
</div>
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>bw_covid <span class="ot">&lt;-</span> <span class="fu">bw</span>(<span class="fu">window</span>(</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>  data_covid[, <span class="fu">c</span>(<span class="st">"bc_fr_m1"</span>, <span class="st">"diff_bc_fr_m1"</span>, <span class="st">"ind2020T1"</span>, <span class="st">"ind2020T2"</span>, </span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>                <span class="st">"ind2020T3"</span>, <span class="st">"ind2020T4"</span>)], <span class="at">start =</span> <span class="dv">1980</span>, <span class="at">end =</span> <span class="fu">c</span>(<span class="dv">2022</span>, <span class="dv">4</span>)), </span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">window</span>(data_covid[, <span class="st">"growth_gdp"</span>], <span class="at">start =</span> <span class="dv">1980</span>, <span class="at">end =</span> <span class="fu">c</span>(<span class="dv">2022</span>, <span class="dv">4</span>))</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a><span class="fu">c</span>(reg_loc<span class="sc">$</span>bw, bw_covid)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.74857843 0.03899898</code></pre>
</div>
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>reg_morc_covid <span class="ot">&lt;-</span> <span class="fu">piece_reg</span>(reg_lin_covid, <span class="at">break_dates =</span> <span class="fl">2000.25</span>,</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>                            <span class="co"># Les indicatrices ne sont pas découpées</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>                            <span class="at">fixed_var =</span> <span class="dv">4</span><span class="sc">:</span><span class="dv">7</span>)</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>reg_loc_covid <span class="ot">&lt;-</span> tvReg<span class="sc">::</span><span class="fu">tvLM</span>(</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">formula =</span> growth_gdp <span class="sc">~</span> bc_fr_m1 <span class="sc">+</span> diff_bc_fr_m1 <span class="sc">+</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>    ind2020T1 <span class="sc">+</span> ind2020T2 <span class="sc">+</span> ind2020T3 <span class="sc">+</span> ind2020T4,</span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>  <span class="at">data =</span> <span class="fu">window</span>(data_covid, <span class="at">start =</span> <span class="dv">1980</span>),</span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>  <span class="co"># On reprend l'ancienne fenêtre</span></span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>  <span class="at">bw =</span> reg_loc<span class="sc">$</span>bw </span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true" tabindex="-1"></a>ssm_covid <span class="ot">&lt;-</span> <span class="fu">ssm_lm</span>(</span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true" tabindex="-1"></a>  reg_lin_covid, </span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true" tabindex="-1"></a>  <span class="at">fixed_var_intercept =</span> <span class="cn">FALSE</span>,</span>
<span id="cb57-14"><a href="#cb57-14" aria-hidden="true" tabindex="-1"></a>  <span class="co"># On fixe les coefficients des indicatrices</span></span>
<span id="cb57-15"><a href="#cb57-15" aria-hidden="true" tabindex="-1"></a>  <span class="co"># et le coefficient du climat des affaires en niveau </span></span>
<span id="cb57-16"><a href="#cb57-16" aria-hidden="true" tabindex="-1"></a>  <span class="co"># (sinon il varie dans le temps)</span></span>
<span id="cb57-17"><a href="#cb57-17" aria-hidden="true" tabindex="-1"></a>  <span class="at">fixed_var_variables =</span> <span class="fu">c</span>(<span class="fu">c</span>(<span class="cn">TRUE</span>, <span class="cn">FALSE</span>), <span class="fu">rep</span>(<span class="cn">TRUE</span>, <span class="dv">4</span>))</span>
<span id="cb57-18"><a href="#cb57-18" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb57-19"><a href="#cb57-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-20"><a href="#cb57-20" aria-hidden="true" tabindex="-1"></a>coef_morc_covid <span class="ot">&lt;-</span> <span class="fu">coef</span>(reg_morc_covid)</span>
<span id="cb57-21"><a href="#cb57-21" aria-hidden="true" tabindex="-1"></a>coef_lin_covid <span class="ot">&lt;-</span> <span class="fu">ts</span>(<span class="fu">matrix</span>(<span class="fu">coef</span>(reg_lin_covid), <span class="at">nrow =</span> <span class="dv">1</span>), </span>
<span id="cb57-22"><a href="#cb57-22" aria-hidden="true" tabindex="-1"></a>               <span class="at">start =</span> <span class="fu">start</span>(coef_morc_covid),</span>
<span id="cb57-23"><a href="#cb57-23" aria-hidden="true" tabindex="-1"></a>               <span class="at">end =</span> <span class="fu">end</span>(coef_morc_covid),</span>
<span id="cb57-24"><a href="#cb57-24" aria-hidden="true" tabindex="-1"></a>               <span class="at">frequency =</span> <span class="fu">frequency</span>(coef_morc_covid))</span>
<span id="cb57-25"><a href="#cb57-25" aria-hidden="true" tabindex="-1"></a><span class="fu">colnames</span>(coef_lin_covid) <span class="ot">&lt;-</span> <span class="fu">names</span>(<span class="fu">coef</span>(reg_lin_covid))</span>
<span id="cb57-26"><a href="#cb57-26" aria-hidden="true" tabindex="-1"></a>coef_reg_loc_covid <span class="ot">&lt;-</span> <span class="fu">ts</span>(<span class="fu">coef</span>(reg_loc_covid), <span class="at">start =</span> <span class="dv">1980</span>, <span class="at">frequency =</span> <span class="dv">4</span>)</span>
<span id="cb57-27"><a href="#cb57-27" aria-hidden="true" tabindex="-1"></a>coef_ssm_covid <span class="ot">&lt;-</span> <span class="fu">coef</span>(ssm_covid)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>La <a href="#fig-coef-covid" class="quarto-xref">figure&nbsp;7</a> montre les coefficients estimés avec en prenant en compte les données jusqu’au 2022T4. L’analyse est similaire à celle de la <a href="#fig-coef-ssm" class="quarto-xref">figure&nbsp;6</a>.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-coef-covid" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-fig" id="fig-coef-covid-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;7- Coefficients estimés (hors indicatrices) par régression linéaire, régression par morceaux, régression locale (avec <span class="math inline">\(b=0,74\)</span>) et modèle espace-état en utilisant les données jusqu’en 2022T4.
</figcaption>
<div aria-describedby="fig-coef-covid-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="DT-tvcoef_files/figure-html/fig-coef-covid-1.png" class="img-fluid figure-img" width="672">
</div>
</figure>
</div>
</div>
</div>
<p>Dans les données ici utilisées, le taux de croissance trimestriel du PIB est connu jusqu’au 2022T4 alors que les variables explicatives sont connues jusqu’au 2023T1 :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="fu">tail</span>(data_covid[, <span class="fu">c</span>(<span class="st">"growth_gdp"</span>, <span class="st">"bc_fr_m1"</span>, <span class="st">"diff_bc_fr_m1"</span>)], <span class="dv">2</span>)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        growth_gdp bc_fr_m1 diff_bc_fr_m1
2022 Q4 0.07510078    102.1          -0.7
2023 Q1         NA    102.0          -0.1</code></pre>
</div>
</div>
<p>Il est donc possible d’effectuer une prévision sur le dernier trimestre et nous allons maintenant montrer comment procéder. Le plus simple est d’effectuer une somme pondérée des variables explicatives avec les coefficients estimés. Dans cet exemple, les variables explicatives sont directement calculées dans la base de données en entrée et sont donc facile à extraire. Lorsque ce n’est pas le cas (par exemple lorsque des variables retardées ou en différence sont directement calculées dans la formule de la fonction <code>dynlm()</code><a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>) il faut alors recalculer toutes les variables explicatives. La fonction <code>tvCoef::full_exogeneous_matrix()</code> peut aider à effectuer cette tache et calcule également le régresseur associé à la constante (égal à 1) :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>data_prev <span class="ot">&lt;-</span> <span class="fu">full_exogeneous_matrix</span>(reg_lin_covid)</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="co"># On extrait le dernier trimestre :</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>der_period <span class="ot">&lt;-</span> <span class="fu">tail</span>(data_prev, <span class="dv">1</span>)</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>der_period</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        (Intercept) bc_fr_m1 diff_bc_fr_m1 ind2020T1 ind2020T2 ind2020T3
2023 Q1           1      102          -0.1         0         0         0
        ind2020T4
2023 Q1         0</code></pre>
</div>
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Transformation en numeric pour éviter des erreurs dues au format ts()</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>der_period <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(der_period)</span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>prev_reg_lin <span class="ot">&lt;-</span> <span class="fu">sum</span>(<span class="fu">coef</span>(reg_lin_covid) <span class="sc">*</span> der_period)</span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Pour les autres méthodes on prend les derniers coefficients estimés</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>prev_reg_morc <span class="ot">&lt;-</span> <span class="fu">sum</span>(<span class="fu">tail</span>(<span class="fu">coef</span>(reg_morc_covid), <span class="dv">1</span>) <span class="sc">*</span> der_period)</span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>prev_reg_loc <span class="ot">&lt;-</span> <span class="fu">sum</span>(<span class="fu">tail</span>(<span class="fu">coef</span>(reg_loc_covid), <span class="dv">1</span>) <span class="sc">*</span> der_period)</span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>prev_ssm <span class="ot">&lt;-</span> <span class="fu">sum</span>(<span class="fu">tail</span>(<span class="fu">coef</span>(ssm_covid), <span class="dv">1</span>) <span class="sc">*</span> der_period)</span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a><span class="fu">round</span>(</span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">c</span>(prev_reg_lin, prev_reg_morc, prev_reg_loc, prev_ssm), </span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a>  <span class="dv">2</span>)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.49 0.37 0.36 0.36</code></pre>
</div>
</div>
</section>
</section>
<section id="sec-comp-generales" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Comparaison générale</h1>
<p>Dans cette section nous effectuons une comparaison plus détaillée des différentes méthodes utilisées. Pour cela, nous utilisons 28 modèles de prévisions des taux de croissance trimestriels de l’industrie manufacturière et de ses principales sous-branches. Les modèles sont estimés entre 1992 et 2019 en utilisant des données issues des enquêtes de conjoncture de l’Insee et de la Banque de France, ainsi que l’Indice de Production Industrielle des branches étudiées. Parmi ces 28 modèles, la procédure de Bai et Perron détecte au moins une rupture sur 14 modèles et le test de Hansen conclut à la présence de coefficients mobiles dans 12 modèles (<a href="#tbl-nb-models" class="quarto-xref">table&nbsp;3</a>). Cela permet donc également de comparer les résultats de la régression locale et de la modélisation espace-état lorsque les coefficients ne sont pas considérés comme fixes par les tests étudiés. Dans la suite, nous considérerons qu’un modèle n’a pas de rupture lorsque le test de Bai et Perron n’en détecte aucune : dans ce cas, la régression par morceaux donne le même résultat que la régression linéaire.</p>
<div id="tbl-nb-models" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-nb-models-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;3- Nombre de modèles étudiés par branche d’activité.
</figcaption>
<div aria-describedby="tbl-nb-models-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell">
<div class="cell-output-display">
<div id="lageasqxxx" style="padding-left:0px;padding-right:0px;padding-top:10px;padding-bottom:10px;overflow-x:auto;overflow-y:auto;width:auto;height:auto;">
<style>#lageasqxxx table {
  font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

#lageasqxxx thead, #lageasqxxx tbody, #lageasqxxx tfoot, #lageasqxxx tr, #lageasqxxx td, #lageasqxxx th {
  border-style: none;
}

#lageasqxxx p {
  margin: 0;
  padding: 0;
}

#lageasqxxx .gt_table {
  display: table;
  border-collapse: collapse;
  line-height: normal;
  margin-left: auto;
  margin-right: auto;
  color: #333333;
  font-size: 16px;
  font-weight: normal;
  font-style: normal;
  background-color: #FFFFFF;
  width: auto;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #A8A8A8;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #A8A8A8;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
}

#lageasqxxx .gt_caption {
  padding-top: 4px;
  padding-bottom: 4px;
}

#lageasqxxx .gt_title {
  color: #333333;
  font-size: 125%;
  font-weight: initial;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 5px;
  padding-right: 5px;
  border-bottom-color: #FFFFFF;
  border-bottom-width: 0;
}

#lageasqxxx .gt_subtitle {
  color: #333333;
  font-size: 85%;
  font-weight: initial;
  padding-top: 3px;
  padding-bottom: 5px;
  padding-left: 5px;
  padding-right: 5px;
  border-top-color: #FFFFFF;
  border-top-width: 0;
}

#lageasqxxx .gt_heading {
  background-color: #FFFFFF;
  text-align: center;
  border-bottom-color: #FFFFFF;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
}

#lageasqxxx .gt_bottom_border {
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

#lageasqxxx .gt_col_headings {
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
}

#lageasqxxx .gt_col_heading {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: normal;
  text-transform: inherit;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: bottom;
  padding-top: 5px;
  padding-bottom: 6px;
  padding-left: 5px;
  padding-right: 5px;
  overflow-x: hidden;
}

#lageasqxxx .gt_column_spanner_outer {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: normal;
  text-transform: inherit;
  padding-top: 0;
  padding-bottom: 0;
  padding-left: 4px;
  padding-right: 4px;
}

#lageasqxxx .gt_column_spanner_outer:first-child {
  padding-left: 0;
}

#lageasqxxx .gt_column_spanner_outer:last-child {
  padding-right: 0;
}

#lageasqxxx .gt_column_spanner {
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  vertical-align: bottom;
  padding-top: 5px;
  padding-bottom: 5px;
  overflow-x: hidden;
  display: inline-block;
  width: 100%;
}

#lageasqxxx .gt_spanner_row {
  border-bottom-style: hidden;
}

#lageasqxxx .gt_group_heading {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: middle;
  text-align: left;
}

#lageasqxxx .gt_empty_group_heading {
  padding: 0.5px;
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  vertical-align: middle;
}

#lageasqxxx .gt_from_md > :first-child {
  margin-top: 0;
}

#lageasqxxx .gt_from_md > :last-child {
  margin-bottom: 0;
}

#lageasqxxx .gt_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  margin: 10px;
  border-top-style: solid;
  border-top-width: 1px;
  border-top-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: middle;
  overflow-x: hidden;
}

#lageasqxxx .gt_stub {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-right-style: solid;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  padding-left: 5px;
  padding-right: 5px;
}

#lageasqxxx .gt_stub_row_group {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-right-style: solid;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  padding-left: 5px;
  padding-right: 5px;
  vertical-align: top;
}

#lageasqxxx .gt_row_group_first td {
  border-top-width: 2px;
}

#lageasqxxx .gt_row_group_first th {
  border-top-width: 2px;
}

#lageasqxxx .gt_summary_row {
  color: #333333;
  background-color: #FFFFFF;
  text-transform: inherit;
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
}

#lageasqxxx .gt_first_summary_row {
  border-top-style: solid;
  border-top-color: #D3D3D3;
}

#lageasqxxx .gt_first_summary_row.thick {
  border-top-width: 2px;
}

#lageasqxxx .gt_last_summary_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

#lageasqxxx .gt_grand_summary_row {
  color: #333333;
  background-color: #FFFFFF;
  text-transform: inherit;
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
}

#lageasqxxx .gt_first_grand_summary_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-top-style: double;
  border-top-width: 6px;
  border-top-color: #D3D3D3;
}

#lageasqxxx .gt_last_grand_summary_row_top {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-bottom-style: double;
  border-bottom-width: 6px;
  border-bottom-color: #D3D3D3;
}

#lageasqxxx .gt_striped {
  background-color: rgba(128, 128, 128, 0.05);
}

#lageasqxxx .gt_table_body {
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

#lageasqxxx .gt_footnotes {
  color: #333333;
  background-color: #FFFFFF;
  border-bottom-style: none;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
}

#lageasqxxx .gt_footnote {
  margin: 0px;
  font-size: 90%;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 5px;
  padding-right: 5px;
}

#lageasqxxx .gt_sourcenotes {
  color: #333333;
  background-color: #FFFFFF;
  border-bottom-style: none;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
}

#lageasqxxx .gt_sourcenote {
  font-size: 90%;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 5px;
  padding-right: 5px;
}

#lageasqxxx .gt_left {
  text-align: left;
}

#lageasqxxx .gt_center {
  text-align: center;
}

#lageasqxxx .gt_right {
  text-align: right;
  font-variant-numeric: tabular-nums;
}

#lageasqxxx .gt_font_normal {
  font-weight: normal;
}

#lageasqxxx .gt_font_bold {
  font-weight: bold;
}

#lageasqxxx .gt_font_italic {
  font-style: italic;
}

#lageasqxxx .gt_super {
  font-size: 65%;
}

#lageasqxxx .gt_footnote_marks {
  font-size: 75%;
  vertical-align: 0.4em;
  position: initial;
}

#lageasqxxx .gt_asterisk {
  font-size: 100%;
  vertical-align: 0;
}

#lageasqxxx .gt_indent_1 {
  text-indent: 5px;
}

#lageasqxxx .gt_indent_2 {
  text-indent: 10px;
}

#lageasqxxx .gt_indent_3 {
  text-indent: 15px;
}

#lageasqxxx .gt_indent_4 {
  text-indent: 20px;
}

#lageasqxxx .gt_indent_5 {
  text-indent: 25px;
}
</style>

<table class="gt_table table table-sm table-striped small" data-quarto-postprocess="true" data-quarto-disable-processing="false" data-quarto-bootstrap="false">
<thead>
<tr class="header gt_col_headings gt_spanner_row">
<th rowspan="2" class="gt_col_heading gt_columns_bottom_border gt_left" data-quarto-table-cell-role="th" scope="col"></th>
<th rowspan="2" id="Total" class="gt_col_heading gt_columns_bottom_border gt_center" data-quarto-table-cell-role="th" scope="col">Total</th>
<th colspan="2" id="Avec rupture" class="gt_center gt_columns_top_border gt_column_spanner_outer" data-quarto-table-cell-role="th" scope="colgroup"><span class="gt_column_spanner">Avec rupture</span></th>
</tr>
<tr class="odd gt_col_headings">
<th id="Bai et Perron" class="gt_col_heading gt_columns_bottom_border gt_center" data-quarto-table-cell-role="th" scope="col">Bai et Perron</th>
<th id="Hansen" class="gt_col_heading gt_columns_bottom_border gt_center" data-quarto-table-cell-role="th" scope="col">Hansen</th>
</tr>
</thead>
<tbody class="gt_table_body">
<tr class="odd">
<td id="stub_1_1" class="gt_row gt_left gt_stub" data-quarto-table-cell-role="th" scope="row">Industrie manufacturière (C)</td>
<td class="gt_row gt_center" headers="stub_1_1 Total">3</td>
<td class="gt_row gt_center" headers="stub_1_1 Bai et Perron">2</td>
<td class="gt_row gt_center" headers="stub_1_1 Hansen">2</td>
</tr>
<tr class="even">
<td id="stub_1_2" class="gt_row gt_left gt_stub" data-quarto-table-cell-role="th" scope="row">Agro–alimentaire (C1)</td>
<td class="gt_row gt_center" headers="stub_1_2 Total">7</td>
<td class="gt_row gt_center" headers="stub_1_2 Bai et Perron">0</td>
<td class="gt_row gt_center" headers="stub_1_2 Hansen">0</td>
</tr>
<tr class="odd">
<td id="stub_1_3" class="gt_row gt_left gt_stub" data-quarto-table-cell-role="th" scope="row">Biens d'équipement (C3)</td>
<td class="gt_row gt_center" headers="stub_1_3 Total">6</td>
<td class="gt_row gt_center" headers="stub_1_3 Bai et Perron">4</td>
<td class="gt_row gt_center" headers="stub_1_3 Hansen">5</td>
</tr>
<tr class="even">
<td id="stub_1_4" class="gt_row gt_left gt_stub" data-quarto-table-cell-role="th" scope="row">Matériels de transport (C4)</td>
<td class="gt_row gt_center" headers="stub_1_4 Total">6</td>
<td class="gt_row gt_center" headers="stub_1_4 Bai et Perron">2</td>
<td class="gt_row gt_center" headers="stub_1_4 Hansen">0</td>
</tr>
<tr class="odd">
<td id="stub_1_5" class="gt_row gt_left gt_stub" data-quarto-table-cell-role="th" scope="row">Autres industries (C5)</td>
<td class="gt_row gt_center" headers="stub_1_5 Total">6</td>
<td class="gt_row gt_center" headers="stub_1_5 Bai et Perron">6</td>
<td class="gt_row gt_center" headers="stub_1_5 Hansen">5</td>
</tr>
<tr class="even">
<td id="grand_summary_stub_1" class="gt_row gt_left gt_stub gt_grand_summary_row gt_first_grand_summary_row gt_last_summary_row" data-quarto-table-cell-role="th" scope="row">Total</td>
<td class="gt_row gt_center gt_grand_summary_row gt_first_grand_summary_row gt_last_summary_row" headers="grand_summary_stub_1 Total">28</td>
<td class="gt_row gt_center gt_grand_summary_row gt_first_grand_summary_row gt_last_summary_row" headers="grand_summary_stub_1 Bai et Perron">14</td>
<td class="gt_row gt_center gt_grand_summary_row gt_first_grand_summary_row gt_last_summary_row" headers="grand_summary_stub_1 Hansen">12</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Lecture : dans la branche des biens d’équipement (C3), 6 modèles sont étudiés. Dans 4 de ces modèles la procédure de Bai et Perron conclut à la présence d’au moins une rupture et le test d’Hansen conclut que les coefficients sont mobiles dans 5 de ces modèles.</p>
</div>
</figure>
</div>
<p>Pour l’estimation des modèles des modèles de régression par morceaux, nous limitons le nombre maximal de ruptures à 2. La dernière rupture est détectée en 2011Q4 pour deux modèles de la branche des autres industries (C5). Les prévisions en hors échantillon sont donc calculées après 2013 afin d’éviter les fortes erreurs autour des ruptures. Pour la régression locale et la modélisation espace-état, les modèles sont estimés avec les paramètres par défaut sans chercher à optimiser les modèles (par exemple en ne fixant pas les coefficients des indicatrices). Ainsi, même si les estimations pourrait être améliorées, cela permet d’étudier leur qualité prédictive dans le cas le moins favorable.</p>
<p>Si l’on souhaite comparer les résultats entre les différentes branches, il est nécessaire de normaliser les erreurs de prévision. Les indicateurs classiques, tels que l’erreur absolue moyenne en pourcentage, normalisent en utilisant la variable à prévoir. Cela nécessite toutefois que ces variables soient positives et non nulles, ce qui n’est pas le cas des taux de croissance. C’est pourquoi dans cette section nous utilisons la moyenne absolue des erreurs normalisées — <em>Mean absolute scaled error</em> (MASE) — proposée par <span class="citation" data-cites="HYNDMAN2006679">Rob J. Hyndman et Koehler (<a href="#ref-HYNDMAN2006679" role="doc-biblioref">2006</a>)</span> : <span class="math display">\[
MASE=moyenne\left(\frac{|{\hat y}_{t} - y_t|}{Q}\right),
\]</span> où <span class="math inline">\(Q\)</span> est une mesure stable de l’échelle de la série. Pour les séries non saisonnières, ce qui est ici le cas, nous utilisons : <span class="math display">\[
Q=\frac{1}{T-1}\sum_{t=2}^T|y_t-y_{t-1}|.
\]</span></p>
<p>La <a href="#tbl-error-table" class="quarto-xref">table&nbsp;4</a> montre les résultats des MASE associées différentes méthodes relativement aux prévisions du modèle de régression linéaire. Dans l’ensemble ce sont les modèles espace-état qui donne les meilleurs résultats. Pour les modèles où une rupture a été détectée, les modèles espace état permettent d’améliorer la qualité d’en moyenne 18&nbsp;% par rapport à la régression linéaire (avec un minimum de 6&nbsp;%), contre une amélioration d’en moyenne 12&nbsp;% ou 11&nbsp;% pour la régression locale et la régression par morceaux. Hors échantillon, les résultats sont également améliorés avec la modélisation espace état pour la majorité des modèles (en moyenne de 7&nbsp;% et au maximum de 20&nbsp;%) mais sont dégradés pour 3 des 14 modèles (d’au plus 5&nbsp;%). Pour la régression locale, les résultats sont, dans la majorité des cas (12 modèles sur 14) identiques ou dégradés par rapport à la régression linéaire (avec une dégradation d’au plus 17&nbsp;%). Pour la régression par morceaux, même si pour 8 séries les résultats sont améliorées, cette amélioration semble moins forte qu’avec les modèles espace (au plus 11&nbsp;%).</p>
<p>Étonnamment, lorsqu’aucune rupture n’est détectée les modèles espace-état permettent également d’améliorer les résultats : dans l’échantillon les erreurs de prévisions sont réduites d’en moyenne 7&nbsp;% et d’au plus 22&nbsp;% et ne sont jamais dégradées. Elles sont en revanche dégradées pour quelques modèles en temps réel (d’au plus 7&nbsp;%), elle sont améliorées pour 3 modèles (jusqu’à 27&nbsp;%). Cette instabilité provient également du fait qu’aucune optimisation n’est faite dans la spécification des modèles. Toutefois ces résultats suggèrent que les tests ici présentés pour tester la constance des coefficients ne sont pas toujours pertinents. Ainsi, <span class="citation" data-cites="abs2006">Zhang et Poskitt (<a href="#ref-abs2006" role="doc-biblioref">2006</a>)</span> proposent une procédure de tests basée sur la modélisation espace état (en testant la significativité de la variance des coefficients estimés).</p>
<div id="tbl-error-table" class="quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-tbl" id="tbl-error-table-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Table&nbsp;4- Moyenne absolue des erreurs normalisées (MASE) rapportée à celle des modèles régression linéaire.
</figcaption>
<div aria-describedby="tbl-error-table-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell">
<div class="cell-output-display">
<div id="aqilgylhcz" style="padding-left:0px;padding-right:0px;padding-top:10px;padding-bottom:10px;overflow-x:auto;overflow-y:auto;width:auto;height:auto;">
<style>#aqilgylhcz table {
  font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

#aqilgylhcz thead, #aqilgylhcz tbody, #aqilgylhcz tfoot, #aqilgylhcz tr, #aqilgylhcz td, #aqilgylhcz th {
  border-style: none;
}

#aqilgylhcz p {
  margin: 0;
  padding: 0;
}

#aqilgylhcz .gt_table {
  display: table;
  border-collapse: collapse;
  line-height: normal;
  margin-left: auto;
  margin-right: auto;
  color: #333333;
  font-size: 16px;
  font-weight: normal;
  font-style: normal;
  background-color: #FFFFFF;
  width: auto;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #A8A8A8;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #A8A8A8;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
}

#aqilgylhcz .gt_caption {
  padding-top: 4px;
  padding-bottom: 4px;
}

#aqilgylhcz .gt_title {
  color: #333333;
  font-size: 125%;
  font-weight: initial;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 5px;
  padding-right: 5px;
  border-bottom-color: #FFFFFF;
  border-bottom-width: 0;
}

#aqilgylhcz .gt_subtitle {
  color: #333333;
  font-size: 85%;
  font-weight: initial;
  padding-top: 3px;
  padding-bottom: 5px;
  padding-left: 5px;
  padding-right: 5px;
  border-top-color: #FFFFFF;
  border-top-width: 0;
}

#aqilgylhcz .gt_heading {
  background-color: #FFFFFF;
  text-align: center;
  border-bottom-color: #FFFFFF;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
}

#aqilgylhcz .gt_bottom_border {
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

#aqilgylhcz .gt_col_headings {
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
}

#aqilgylhcz .gt_col_heading {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: normal;
  text-transform: inherit;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: bottom;
  padding-top: 5px;
  padding-bottom: 6px;
  padding-left: 5px;
  padding-right: 5px;
  overflow-x: hidden;
}

#aqilgylhcz .gt_column_spanner_outer {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: normal;
  text-transform: inherit;
  padding-top: 0;
  padding-bottom: 0;
  padding-left: 4px;
  padding-right: 4px;
}

#aqilgylhcz .gt_column_spanner_outer:first-child {
  padding-left: 0;
}

#aqilgylhcz .gt_column_spanner_outer:last-child {
  padding-right: 0;
}

#aqilgylhcz .gt_column_spanner {
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  vertical-align: bottom;
  padding-top: 5px;
  padding-bottom: 5px;
  overflow-x: hidden;
  display: inline-block;
  width: 100%;
}

#aqilgylhcz .gt_spanner_row {
  border-bottom-style: hidden;
}

#aqilgylhcz .gt_group_heading {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: middle;
  text-align: left;
}

#aqilgylhcz .gt_empty_group_heading {
  padding: 0.5px;
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  vertical-align: middle;
}

#aqilgylhcz .gt_from_md > :first-child {
  margin-top: 0;
}

#aqilgylhcz .gt_from_md > :last-child {
  margin-bottom: 0;
}

#aqilgylhcz .gt_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  margin: 10px;
  border-top-style: solid;
  border-top-width: 1px;
  border-top-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: middle;
  overflow-x: hidden;
}

#aqilgylhcz .gt_stub {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-right-style: solid;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  padding-left: 5px;
  padding-right: 5px;
}

#aqilgylhcz .gt_stub_row_group {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-right-style: solid;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  padding-left: 5px;
  padding-right: 5px;
  vertical-align: top;
}

#aqilgylhcz .gt_row_group_first td {
  border-top-width: 2px;
}

#aqilgylhcz .gt_row_group_first th {
  border-top-width: 2px;
}

#aqilgylhcz .gt_summary_row {
  color: #333333;
  background-color: #FFFFFF;
  text-transform: inherit;
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
}

#aqilgylhcz .gt_first_summary_row {
  border-top-style: solid;
  border-top-color: #D3D3D3;
}

#aqilgylhcz .gt_first_summary_row.thick {
  border-top-width: 2px;
}

#aqilgylhcz .gt_last_summary_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

#aqilgylhcz .gt_grand_summary_row {
  color: #333333;
  background-color: #FFFFFF;
  text-transform: inherit;
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
}

#aqilgylhcz .gt_first_grand_summary_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-top-style: double;
  border-top-width: 6px;
  border-top-color: #D3D3D3;
}

#aqilgylhcz .gt_last_grand_summary_row_top {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-bottom-style: double;
  border-bottom-width: 6px;
  border-bottom-color: #D3D3D3;
}

#aqilgylhcz .gt_striped {
  background-color: rgba(128, 128, 128, 0.05);
}

#aqilgylhcz .gt_table_body {
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

#aqilgylhcz .gt_footnotes {
  color: #333333;
  background-color: #FFFFFF;
  border-bottom-style: none;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
}

#aqilgylhcz .gt_footnote {
  margin: 0px;
  font-size: 90%;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 5px;
  padding-right: 5px;
}

#aqilgylhcz .gt_sourcenotes {
  color: #333333;
  background-color: #FFFFFF;
  border-bottom-style: none;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
}

#aqilgylhcz .gt_sourcenote {
  font-size: 90%;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 5px;
  padding-right: 5px;
}

#aqilgylhcz .gt_left {
  text-align: left;
}

#aqilgylhcz .gt_center {
  text-align: center;
}

#aqilgylhcz .gt_right {
  text-align: right;
  font-variant-numeric: tabular-nums;
}

#aqilgylhcz .gt_font_normal {
  font-weight: normal;
}

#aqilgylhcz .gt_font_bold {
  font-weight: bold;
}

#aqilgylhcz .gt_font_italic {
  font-style: italic;
}

#aqilgylhcz .gt_super {
  font-size: 65%;
}

#aqilgylhcz .gt_footnote_marks {
  font-size: 75%;
  vertical-align: 0.4em;
  position: initial;
}

#aqilgylhcz .gt_asterisk {
  font-size: 100%;
  vertical-align: 0;
}

#aqilgylhcz .gt_indent_1 {
  text-indent: 5px;
}

#aqilgylhcz .gt_indent_2 {
  text-indent: 10px;
}

#aqilgylhcz .gt_indent_3 {
  text-indent: 15px;
}

#aqilgylhcz .gt_indent_4 {
  text-indent: 20px;
}

#aqilgylhcz .gt_indent_5 {
  text-indent: 25px;
}
</style>

<table class="gt_table table table-sm table-striped small" data-quarto-postprocess="true" data-quarto-disable-processing="false" data-quarto-bootstrap="false">
<thead>
<tr class="header gt_col_headings gt_spanner_row">
<th rowspan="2" class="gt_col_heading gt_columns_bottom_border gt_left" data-quarto-table-cell-role="th" scope="col"></th>
<th rowspan="2" id="Moyenne" class="gt_col_heading gt_columns_bottom_border gt_center" data-quarto-table-cell-role="th" scope="col">Moyenne</th>
<th rowspan="2" id="Min" class="gt_col_heading gt_columns_bottom_border gt_center" data-quarto-table-cell-role="th" scope="col">Min</th>
<th rowspan="2" id="Max" class="gt_col_heading gt_columns_bottom_border gt_center" data-quarto-table-cell-role="th" scope="col">Max</th>
<th colspan="3" id="Séries dont MASE" class="gt_center gt_columns_top_border gt_column_spanner_outer" data-quarto-table-cell-role="th" scope="colgroup"><span class="gt_column_spanner">Séries dont MASE</span></th>
</tr>
<tr class="odd gt_col_headings">
<th id="&amp;lt; 1" class="gt_col_heading gt_columns_bottom_border gt_center" data-quarto-table-cell-role="th" scope="col">&lt; 1</th>
<th id="= 1" class="gt_col_heading gt_columns_bottom_border gt_center" data-quarto-table-cell-role="th" scope="col">= 1</th>
<th id="&amp;gt; 1" class="gt_col_heading gt_columns_bottom_border gt_center" data-quarto-table-cell-role="th" scope="col">&gt; 1</th>
</tr>
</thead>
<tbody class="gt_table_body">
<tr class="odd gt_group_heading_row">
<td colspan="7" id="Sans rupture - Dans l'échantillon" class="gt_group_heading" data-quarto-table-cell-role="th" scope="colgroup">Sans rupture - Dans l'échantillon</td>
</tr>
<tr class="even gt_row_group_first">
<td id="stub_1_1" class="gt_row gt_left gt_stub" data-quarto-table-cell-role="th" scope="row">Rég. par morceaux</td>
<td class="gt_row gt_center" headers="Sans rupture - Dans l'échantillon stub_1_1 Moyenne">1,00</td>
<td class="gt_row gt_center" headers="Sans rupture - Dans l'échantillon stub_1_1 Min">1,00</td>
<td class="gt_row gt_center" headers="Sans rupture - Dans l'échantillon stub_1_1 Max">1,00</td>
<td class="gt_row gt_center" headers="Sans rupture - Dans l'échantillon stub_1_1 < 1">0</td>
<td class="gt_row gt_center" headers="Sans rupture - Dans l'échantillon stub_1_1 = 1">14</td>
<td class="gt_row gt_center" headers="Sans rupture - Dans l'échantillon stub_1_1 > 1">0</td>
</tr>
<tr class="odd">
<td id="stub_1_2" class="gt_row gt_left gt_stub" data-quarto-table-cell-role="th" scope="row">Rég. locale</td>
<td class="gt_row gt_center" headers="Sans rupture - Dans l'échantillon stub_1_2 Moyenne">1,00</td>
<td class="gt_row gt_center" headers="Sans rupture - Dans l'échantillon stub_1_2 Min">0,98</td>
<td class="gt_row gt_center" headers="Sans rupture - Dans l'échantillon stub_1_2 Max">1,00</td>
<td class="gt_row gt_center" headers="Sans rupture - Dans l'échantillon stub_1_2 < 1">3</td>
<td class="gt_row gt_center" headers="Sans rupture - Dans l'échantillon stub_1_2 = 1">11</td>
<td class="gt_row gt_center" headers="Sans rupture - Dans l'échantillon stub_1_2 > 1">0</td>
</tr>
<tr class="even">
<td id="stub_1_3" class="gt_row gt_left gt_stub" data-quarto-table-cell-role="th" scope="row">Mod. espace-état</td>
<td class="gt_row gt_center" headers="Sans rupture - Dans l'échantillon stub_1_3 Moyenne">0,93</td>
<td class="gt_row gt_center" headers="Sans rupture - Dans l'échantillon stub_1_3 Min">0,78</td>
<td class="gt_row gt_center" headers="Sans rupture - Dans l'échantillon stub_1_3 Max">1,00</td>
<td class="gt_row gt_center" headers="Sans rupture - Dans l'échantillon stub_1_3 < 1">7</td>
<td class="gt_row gt_center" headers="Sans rupture - Dans l'échantillon stub_1_3 = 1">7</td>
<td class="gt_row gt_center" headers="Sans rupture - Dans l'échantillon stub_1_3 > 1">0</td>
</tr>
<tr class="odd gt_group_heading_row">
<td colspan="7" id="Sans rupture - Hors échantillon" class="gt_group_heading" data-quarto-table-cell-role="th" scope="colgroup">Sans rupture - Hors échantillon</td>
</tr>
<tr class="even gt_row_group_first">
<td id="stub_1_4" class="gt_row gt_left gt_stub" data-quarto-table-cell-role="th" scope="row">Rég. par morceaux</td>
<td class="gt_row gt_center" headers="Sans rupture - Hors échantillon stub_1_4 Moyenne">1,00</td>
<td class="gt_row gt_center" headers="Sans rupture - Hors échantillon stub_1_4 Min">1,00</td>
<td class="gt_row gt_center" headers="Sans rupture - Hors échantillon stub_1_4 Max">1,00</td>
<td class="gt_row gt_center" headers="Sans rupture - Hors échantillon stub_1_4 < 1">0</td>
<td class="gt_row gt_center" headers="Sans rupture - Hors échantillon stub_1_4 = 1">14</td>
<td class="gt_row gt_center" headers="Sans rupture - Hors échantillon stub_1_4 > 1">0</td>
</tr>
<tr class="odd">
<td id="stub_1_5" class="gt_row gt_left gt_stub" data-quarto-table-cell-role="th" scope="row">Rég. locale</td>
<td class="gt_row gt_center" headers="Sans rupture - Hors échantillon stub_1_5 Moyenne">1,01</td>
<td class="gt_row gt_center" headers="Sans rupture - Hors échantillon stub_1_5 Min">0,99</td>
<td class="gt_row gt_center" headers="Sans rupture - Hors échantillon stub_1_5 Max">1,07</td>
<td class="gt_row gt_center" headers="Sans rupture - Hors échantillon stub_1_5 < 1">1</td>
<td class="gt_row gt_center" headers="Sans rupture - Hors échantillon stub_1_5 = 1">7</td>
<td class="gt_row gt_center" headers="Sans rupture - Hors échantillon stub_1_5 > 1">6</td>
</tr>
<tr class="even">
<td id="stub_1_6" class="gt_row gt_left gt_stub" data-quarto-table-cell-role="th" scope="row">Mod. espace-état</td>
<td class="gt_row gt_center" headers="Sans rupture - Hors échantillon stub_1_6 Moyenne">0,99</td>
<td class="gt_row gt_center" headers="Sans rupture - Hors échantillon stub_1_6 Min">0,73</td>
<td class="gt_row gt_center" headers="Sans rupture - Hors échantillon stub_1_6 Max">1,07</td>
<td class="gt_row gt_center" headers="Sans rupture - Hors échantillon stub_1_6 < 1">3</td>
<td class="gt_row gt_center" headers="Sans rupture - Hors échantillon stub_1_6 = 1">7</td>
<td class="gt_row gt_center" headers="Sans rupture - Hors échantillon stub_1_6 > 1">4</td>
</tr>
<tr class="odd gt_group_heading_row">
<td colspan="7" id="Avec rupture - Dans l'échantillon" class="gt_group_heading" data-quarto-table-cell-role="th" scope="colgroup">Avec rupture - Dans l'échantillon</td>
</tr>
<tr class="even gt_row_group_first">
<td id="stub_1_7" class="gt_row gt_left gt_stub" data-quarto-table-cell-role="th" scope="row">Rég. par morceaux</td>
<td class="gt_row gt_center" headers="Avec rupture - Dans l'échantillon stub_1_7 Moyenne">0,89</td>
<td class="gt_row gt_center" headers="Avec rupture - Dans l'échantillon stub_1_7 Min">0,79</td>
<td class="gt_row gt_center" headers="Avec rupture - Dans l'échantillon stub_1_7 Max">1,00</td>
<td class="gt_row gt_center" headers="Avec rupture - Dans l'échantillon stub_1_7 < 1">13</td>
<td class="gt_row gt_center" headers="Avec rupture - Dans l'échantillon stub_1_7 = 1">1</td>
<td class="gt_row gt_center" headers="Avec rupture - Dans l'échantillon stub_1_7 > 1">0</td>
</tr>
<tr class="odd">
<td id="stub_1_8" class="gt_row gt_left gt_stub" data-quarto-table-cell-role="th" scope="row">Rég. locale</td>
<td class="gt_row gt_center" headers="Avec rupture - Dans l'échantillon stub_1_8 Moyenne">0,88</td>
<td class="gt_row gt_center" headers="Avec rupture - Dans l'échantillon stub_1_8 Min">0,59</td>
<td class="gt_row gt_center" headers="Avec rupture - Dans l'échantillon stub_1_8 Max">1,01</td>
<td class="gt_row gt_center" headers="Avec rupture - Dans l'échantillon stub_1_8 < 1">13</td>
<td class="gt_row gt_center" headers="Avec rupture - Dans l'échantillon stub_1_8 = 1">0</td>
<td class="gt_row gt_center" headers="Avec rupture - Dans l'échantillon stub_1_8 > 1">1</td>
</tr>
<tr class="even">
<td id="stub_1_9" class="gt_row gt_left gt_stub" data-quarto-table-cell-role="th" scope="row">Mod. espace-état</td>
<td class="gt_row gt_center" headers="Avec rupture - Dans l'échantillon stub_1_9 Moyenne">0,82</td>
<td class="gt_row gt_center" headers="Avec rupture - Dans l'échantillon stub_1_9 Min">0,61</td>
<td class="gt_row gt_center" headers="Avec rupture - Dans l'échantillon stub_1_9 Max">0,94</td>
<td class="gt_row gt_center" headers="Avec rupture - Dans l'échantillon stub_1_9 < 1">14</td>
<td class="gt_row gt_center" headers="Avec rupture - Dans l'échantillon stub_1_9 = 1">0</td>
<td class="gt_row gt_center" headers="Avec rupture - Dans l'échantillon stub_1_9 > 1">0</td>
</tr>
<tr class="odd gt_group_heading_row">
<td colspan="7" id="Avec rupture - Hors échantillon" class="gt_group_heading" data-quarto-table-cell-role="th" scope="colgroup">Avec rupture - Hors échantillon</td>
</tr>
<tr class="even gt_row_group_first">
<td id="stub_1_10" class="gt_row gt_left gt_stub" data-quarto-table-cell-role="th" scope="row">Rég. par morceaux</td>
<td class="gt_row gt_center" headers="Avec rupture - Hors échantillon stub_1_10 Moyenne">1,00</td>
<td class="gt_row gt_center" headers="Avec rupture - Hors échantillon stub_1_10 Min">0,89</td>
<td class="gt_row gt_center" headers="Avec rupture - Hors échantillon stub_1_10 Max">1,18</td>
<td class="gt_row gt_center" headers="Avec rupture - Hors échantillon stub_1_10 < 1">8</td>
<td class="gt_row gt_center" headers="Avec rupture - Hors échantillon stub_1_10 = 1">1</td>
<td class="gt_row gt_center" headers="Avec rupture - Hors échantillon stub_1_10 > 1">5</td>
</tr>
<tr class="odd">
<td id="stub_1_11" class="gt_row gt_left gt_stub" data-quarto-table-cell-role="th" scope="row">Rég. locale</td>
<td class="gt_row gt_center" headers="Avec rupture - Hors échantillon stub_1_11 Moyenne">1,03</td>
<td class="gt_row gt_center" headers="Avec rupture - Hors échantillon stub_1_11 Min">0,91</td>
<td class="gt_row gt_center" headers="Avec rupture - Hors échantillon stub_1_11 Max">1,17</td>
<td class="gt_row gt_center" headers="Avec rupture - Hors échantillon stub_1_11 < 1">2</td>
<td class="gt_row gt_center" headers="Avec rupture - Hors échantillon stub_1_11 = 1">5</td>
<td class="gt_row gt_center" headers="Avec rupture - Hors échantillon stub_1_11 > 1">7</td>
</tr>
<tr class="even">
<td id="stub_1_12" class="gt_row gt_left gt_stub" data-quarto-table-cell-role="th" scope="row">Mod. espace-état</td>
<td class="gt_row gt_center" headers="Avec rupture - Hors échantillon stub_1_12 Moyenne">0,93</td>
<td class="gt_row gt_center" headers="Avec rupture - Hors échantillon stub_1_12 Min">0,80</td>
<td class="gt_row gt_center" headers="Avec rupture - Hors échantillon stub_1_12 Max">1,05</td>
<td class="gt_row gt_center" headers="Avec rupture - Hors échantillon stub_1_12 < 1">11</td>
<td class="gt_row gt_center" headers="Avec rupture - Hors échantillon stub_1_12 = 1">0</td>
<td class="gt_row gt_center" headers="Avec rupture - Hors échantillon stub_1_12 > 1">3</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p>Note : les modèles sans rupture sont ceux où aucune rupture n’est détectée par la procédure de Bai et Perron.</p>
<p>Lecture : pour les prévisions hors échantillon la modélisation permet, par rapport à la régression linéaire, le MASE est réduit d’en moyenne de 7&nbsp;% pour les modèles avec rupture et de 1&nbsp;% pour les modèles sans rupture. Trois modèles sans rupture sont améliorés grâce à la modélisation espace-état (avec une réduction maximale de la MASE de 27&nbsp;%) et les erreurs de prévisions sont augmentées pour quatre modèles (avec une hausse maximale de 7&nbsp;%).</p>
</div>
</figure>
</div>
</section>
<section id="conclusion" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Conclusion</h1>
<p>En conclusion, cette étude montre comment, à partir d’un modèle de régression linéaire, on peut tester l’hypothèse de constance des coefficients et relâcher cette hypothèse en implémentant des modèles de régression par morceaux, de régression mobile et espace-état. Cette implémentation est facilitée grâce au package <code>tvCoef</code> (<a href="https://github.com/InseeFrLab/tvCoef" class="uri">https://github.com/InseeFrLab/tvCoef</a>) qui accompagne cette étude et tous les codes associés sont disponibles sous sous <a href="https://github.com/InseeFrLab/DT-tvcoef" class="uri">https://github.com/InseeFrLab/DT-tvcoef</a>.</p>
<p>Lorsque les tests classiques indiquent une non-constance des coefficients, ces trois méthodes permettent de réduire les erreurs de prévisions dans l’échantillon (lorsque les coefficients sont estimés sur l’ensemble des données). Toutefois, ces trois méthodes reposent sur des hypothèses qui peuvent conduire à des fortes instabilités, notamment si elles sont utilisées naïvement lors des exercices de prévision en temps réel (hors échantillon).<br>
La régression par morceaux supposent la connaissance de dates de ruptures : même si des procédures existent pour leur détection automatique <span class="citation" data-cites="bai2003computation">(<a href="#ref-bai2003computation" role="doc-biblioref">Bai et Perron 2003</a>)</span>, les instabilités autour de celles-ci font qu’il est préférable de s’appuyer sur un raisonnement économique. En effet, si rupture brutale il y a, elle doit pouvoir s’expliquer et le statisticien devrait pouvoir en trouver la cause.<br>
Le paramètre principal de la régression locale est la fenêtre, qui permet de jouer sur la sensibilité des estimations aux observations lointaines. Même s’il existe également des procédures de sélection automatique, celles-ci sont également instables, ce qui conduit, lors des exercices de prévisions en temps réel, à des erreurs de prévisions plus élevées que la régression linéaire lorsque la fenêtre n’est pas fixée.<br>
Enfin, dans les modèles espace-état, des instabilités numériques d’optimisation peuvent conduire à une volatilité dans l’estimation des variances des coefficients (qui déterminent si le coefficient varie ou non dans le temps et à quelle vitesse). C’est toutefois la méthode qui donnent les meilleurs résultats et qui permet dans la majorité des cas de réduire les erreurs de prévision par rapport à la régression linéaire, même les tests classiques indiquent une constance des coefficients !</p>
<p>Même si ces méthodes permettent, par rapport à la régression linéaire, d’améliorer la qualité des prévisions, elles n’ont pas vocation à remplacer les modèles existants mais plutôt à les compléter. En effet, même si dans la majorité des cas les méthodes étudiées permettent de réduire les erreurs de prévision, cela peut ne pas être le cas sur tous les trimestres. D’une part la combinaison de prévisions issues de différents modèles permet généralement d’obtenir une prévision finale plus précise <span class="citation" data-cites="WANG20231518">(voir par exemple <a href="#ref-WANG20231518" role="doc-biblioref">Wang et al. 2023</a> pour une revue de littérature)</span> ; d’autre part, l’interprétation économique et les hypothèses sous-jacentes sont différentes entre chaque modèle : l’analyse faite de la prévision dépend donc également de la conjoncture récente.</p>
<p>Cette étude pourrait être étendue de plusieurs manières. Tout d’abord, les méthodes ici présentées pourraient être améliorées. Par exemple, pour la régression locale et la modélisation espace-état, on suppose que les paramètres évoluent à la même vitesse au cours de toute la période d’estimation (fenêtre fixe et variance fixée). Toutefois, autour des périodes de crises (comme le COVID-19) on pourrait vouloir ajouter plus de flexibilités à l’évolution des coefficients (en réduisant la fenêtre ou en effectuant un choc sur la variance) : cela ajouterait plus de variabilité dans les estimations mais pourrait permettre de mieux prendre en compte les changements structurels.<br>
Ensuite, d’autres méthodes d’estimations pourraient être utilisées pour modéliser l’évolution dans le temps des coefficients. Par exemple <span class="citation" data-cites="melard">Azrak et Mélard (<a href="#ref-melard" role="doc-biblioref">2022</a>)</span> modélise des variations déterministes des coefficients (plutôt que stochastiques comme pour les modèles espace-état).<br>
Enfin, les modèles auraient également pu être comparés aux modèles à seuil et modèles à changement de régime markoviens <span class="citation" data-cites="PETROPOULOS2022705">(voir par exemple <a href="#ref-PETROPOULOS2022705" role="doc-biblioref">Petropoulos et al. 2022</a> pour une revue bibliographique de ces modèles)</span> qui peuvent se voir comme des cas particuliers des méthodes étudiés. En effet, dans les modèles à seuil la rupture est brutale et dépend du niveau d’une variable exogène et dans les modèles à changement de régime markoviens, les coefficients dépendent d’une variable inobservée modélisant la position de l’économie dans le cycle : la rupture est donc brutale et dépend d’une variable externe (comme dans la régression locale). <em>In fine</em>, le choix entre toutes ces méthodes se fait surtout sur les hypothèses économiques que l’on souhaite modéliser.</p>
</section>

<section id="bibliographie" class="level1 unnumbered">
<h1 class="unnumbered">Bibliographie</h1>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-AIC" class="csl-entry" role="listitem">
Anderson, David, et Kenneth Burnham. 2006. <span>«&nbsp;<span>AIC</span> Myths and Misunderstandings&nbsp;»</span>. <a href="https://sites.warnercnr.colostate.edu/kenburnham/wp-content/uploads/sites/25/2016/08/AIC-Myths-and-Misunderstandings.pdf">https://sites.warnercnr.colostate.edu/kenburnham/wp-content/uploads/sites/25/2016/08/AIC-Myths-and-Misunderstandings.pdf</a>.
</div>
<div id="ref-melard" class="csl-entry" role="listitem">
Azrak, Rajae, et Guy Mélard. 2022. <span>«&nbsp;Autoregressive Models with Time-Dependent Coefficients—A Comparison between Several Approaches&nbsp;»</span>. <em>Stats</em> 5 (3): 784‑804. <a href="https://doi.org/10.3390/stats5030046">https://doi.org/10.3390/stats5030046</a>.
</div>
<div id="ref-bai2003computation" class="csl-entry" role="listitem">
Bai, Jushan, et Pierre Perron. 2003. <span>«&nbsp;Computation and analysis of multiple structural change models&nbsp;»</span>. <em>Journal of applied econometrics</em> 18 (1): 1‑22. <a href="https://doi.org/10.1002/jae.659">https://doi.org/10.1002/jae.659</a>.
</div>
<div id="ref-mesange" class="csl-entry" role="listitem">
Bardaji, José, Benoît Campagne, Marie-Baïanne Khder, Quentin Lafféter, Olivier simon, Claire Elezaar Anne-Sophie Dufernez, Pierre Leblanc, Emmanuelle Masson, et Harry Partouche. 2017. <span>«&nbsp;Le mod<span>è</span>le macro<span>é</span>conom<span>é</span>trique M<span>é</span>sange : r<span>é</span>estimation et nouveaut<span>é</span>s&nbsp;»</span>. <em>Document de travail de la Direction des Études et Synthèses Économiques</em>, nᵒ G2017/04. <a href="https://www.insee.fr/fr/statistiques/2848300">https://www.insee.fr/fr/statistiques/2848300</a>.
</div>
<div id="ref-OPTIM" class="csl-entry" role="listitem">
Barhoumi, Karim, V. Brunhes-Lesage, Olivier Darné, Laurent Ferrara, Bertrand Pluyaud, et B. Rouvreau. 2008. <span>«&nbsp;<span>OPTIM</span> : un outil de pr<span>é</span>vision trimestrielle du <span>PIB</span> de la France&nbsp;»</span>. <em>Bulletin de la Banque de France</em>, nᵒ 171: 31‑42. <a href="http://EconPapers.repec.org/RePEc:bfr:bullbf:2008:171:02">http://EconPapers.repec.org/RePEc:bfr:bullbf:2008:171:02</a>.
</div>
<div id="ref-tvReg" class="csl-entry" role="listitem">
Casas, Isabel, et Ruben Fernandez-Casal. 2019. <span>«&nbsp;tvReg: Time-Varying Coefficients Linear Regression for Single and Multi-Equations in R&nbsp;»</span>. SSRN. <a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3363526">https://papers.ssrn.com/sol3/papers.cfm?abstract_id=3363526</a>.
</div>
<div id="ref-chowtest" class="csl-entry" role="listitem">
Chow, Gregory C. 1960. <span>«&nbsp;Tests of Equality Between Sets of Coefficients in Two Linear Regressions&nbsp;»</span>. <em>Econometrica</em> 28 (3): 591‑605. <a href="http://www.jstor.org/stable/1910133">http://www.jstor.org/stable/1910133</a>.
</div>
<div id="ref-tvcoef" class="csl-entry" role="listitem">
de Rosamel, Claire, et Alain Quartier-la-Tente. 2024. <em>tvCoef: Linear Time-Varying Coefficient Models</em>. <a href="https://inseefrlab.github.io/tvCoef/">https://inseefrlab.github.io/tvCoef/</a>.
</div>
<div id="ref-DMtest" class="csl-entry" role="listitem">
Diebold, Francis X. 2012. <span>«&nbsp;Comparing Predictive Accuracy, Twenty Years Late<span>r:</span> A Personal Perspective on the Use and Abuse of <span class="smallcaps">D</span>iebold-<span class="smallcaps">M</span>ariano Tests&nbsp;»</span>. Working Paper 18391. Working Paper Series. National Bureau of Economic Research. <a href="https://doi.org/10.3386/w18391">https://doi.org/10.3386/w18391</a>.
</div>
<div id="ref-durbinkoopman" class="csl-entry" role="listitem">
Durbin, James, et Siem Jan Koopman. 2012. <em><span>Time Series Analysis by State Space Methods</span></em>. Oxford University Press. <a href="https://doi.org/10.1093/acprof:oso/9780199641178.001.0001">https://doi.org/10.1093/acprof:oso/9780199641178.001.0001</a>.
</div>
<div id="ref-engle1987co" class="csl-entry" role="listitem">
Engle, Robert F, et Clive WJ Granger. 1987. <span>«&nbsp;Co-integration and error correction: representation, estimation, and testing&nbsp;»</span>. <em>Econometrica: journal of the Econometric Society</em>, 251‑76.
</div>
<div id="ref-eurostat2015guidelines" class="csl-entry" role="listitem">
Eurostat. 2015. <span>«&nbsp;ESS Guidelines on Seasonal Adjustment&nbsp;»</span>. Eurostat Methodologies; Working Papers, European Commission. <a href="https://doi.org/10.2785/317290">https://doi.org/10.2785/317290</a>.
</div>
<div id="ref-FengSchafer2021" class="csl-entry" role="listitem">
Feng, Yuanhua, et Bastian Schäfer. 2021. <span>«&nbsp;<span>Boundary modification in local polynomial regression</span>&nbsp;»</span>. Working Papers CIE 144. Paderborn University, CIE Center for International Economics. <a href="https://ideas.repec.org/p/pdn/ciepap/144.html">https://ideas.repec.org/p/pdn/ciepap/144.html</a>.
</div>
<div id="ref-roll" class="csl-entry" role="listitem">
Foster, Jason. 2020. <em>roll: Rolling and Expanding Statistics</em>. <a href="https://CRAN.R-project.org/package=roll">https://CRAN.R-project.org/package=roll</a>.
</div>
<div id="ref-car" class="csl-entry" role="listitem">
Fox, John, et Sanford Weisberg. 2019. <em>An <span>R</span> Companion to Applied Regression</em>. Third. Thousand Oaks <span>CA</span>: Sage. <a href="https://socialsciences.mcmaster.ca/jfox/Books/Companion/">https://socialsciences.mcmaster.ca/jfox/Books/Companion/</a>.
</div>
<div id="ref-ndc2015prev" class="csl-entry" role="listitem">
Glotain, Morgane, et Alain Quartier-la-Tente. 2015. <span>«&nbsp;De nouveaux indicateurs de climats des affaires sous-sectoriels pour améliorer le diagnostic conjoncturel&nbsp;»</span>. <em>Note de conjoncture</em>, 35‑56. <a href="https://www.insee.fr/fr/statistiques/fichier/2019067/062016_d2.pdf">https://www.insee.fr/fr/statistiques/fichier/2019067/062016_d2.pdf</a>.
</div>
<div id="ref-hansen1990lagrange" class="csl-entry" role="listitem">
Hansen, Bruce E. 1990. <span>«&nbsp;Lagrange multiplier tests for parameter instability in non-linear models&nbsp;»</span>. <em>University of Rochester</em>. <a href="https://users.ssc.wisc.edu/~bhansen/papers/LMTests.pdf">https://users.ssc.wisc.edu/~bhansen/papers/LMTests.pdf</a>.
</div>
<div id="ref-hansen1992testing" class="csl-entry" role="listitem">
———. 1992a. <span>«&nbsp;Testing for parameter instability in linear models&nbsp;»</span>. <em>Journal of policy Modeling</em> 14 (4): 517‑33. <a href="https://doi.org/10.1016/0161-8938(92)90019-9">https://doi.org/10.1016/0161-8938(92)90019-9</a>.
</div>
<div id="ref-hansen1992I1" class="csl-entry" role="listitem">
———. 1992b. <span>«&nbsp;Tests for Parameter Instability in Regressions with I(1) Processes&nbsp;»</span>. <em>Journal of Business &amp; Economic Statistics</em> 10 (3): 321‑35. <a href="http://www.jstor.org/stable/1391545">http://www.jstor.org/stable/1391545</a>.
</div>
<div id="ref-forecastR" class="csl-entry" role="listitem">
Hyndman, Rob J, et Yeasmin Khandakar. 2008. <span>«&nbsp;Automatic time series forecasting: the forecast package for <span>R</span>&nbsp;»</span>. <em>Journal of Statistical Software</em> 26 (3): 1‑22. <a href="https://doi.org/10.18637/jss.v027.i03">https://doi.org/10.18637/jss.v027.i03</a>.
</div>
<div id="ref-HYNDMAN2006679" class="csl-entry" role="listitem">
Hyndman, Rob J., et Anne B. Koehler. 2006. <span>«&nbsp;Another look at measures of forecast accuracy&nbsp;»</span>. <em>International Journal of Forecasting</em> 22 (4): 679‑88. <a href="https://www.sciencedirect.com/science/article/pii/S0169207006000239">https://www.sciencedirect.com/science/article/pii/S0169207006000239</a>.
</div>
<div id="ref-locfit" class="csl-entry" role="listitem">
Loader, Catherine. 2023. <em>locfit: Local Regression, Likelihood and Density Estimation</em>. <a href="https://CRAN.R-project.org/package=locfit">https://CRAN.R-project.org/package=locfit</a>.
</div>
<div id="ref-Loader1999" class="csl-entry" role="listitem">
Loader, Clive. 1999. <em>Local regression and likelihood</em>. New York: Springer-Verlag.
</div>
<div id="ref-rjd3sts" class="csl-entry" role="listitem">
Palate, Jean. 2023. <em>rjd3sts: State Space Framework and Structural Time Series with ’JDemetra+ 3.0’</em>. <a href="https://github.com/rjdemetra/rjd3sts">https://github.com/rjdemetra/rjd3sts</a>.
</div>
<div id="ref-PETROPOULOS2022705" class="csl-entry" role="listitem">
Petropoulos, Fotios, Daniele Apiletti, Vassilios Assimakopoulos, Mohamed Zied Babai, Devon K. Barrow, Souhaib Ben Taieb, Christoph Bergmeir, et al. 2022. <span>«&nbsp;Forecasting: theory and practice&nbsp;»</span>. <em>International Journal of Forecasting</em> 38 (3): 705‑871. <a href="https://doi.org/10.1016/j.ijforecast.2021.11.001">https://doi.org/10.1016/j.ijforecast.2021.11.001</a>.
</div>
<div id="ref-JMS2018" class="csl-entry" role="listitem">
Pham, Hien, et Alain Quartier-la-Tente. 2018. <span>«&nbsp;D<span>é</span>saisonnaliser les s<span>é</span>ries tr<span>è</span>s longues par sous-p<span>é</span>riode, gains et choix de la longueur de traitement - exemple des s<span>é</span>ries de l’IPI&nbsp;»</span>. <em>XIII<span>è</span>mes Journ<span>é</span>es de M<span>é</span>thodologie Statistique de l’Insee</em>. <a href="http://www.jms-insee.fr/2018/S05_2_ACTEv3_PHAM_JMS2018.pdf">http://www.jms-insee.fr/2018/S05_2_ACTEv3_PHAM_JMS2018.pdf</a>.
</div>
<div id="ref-WANG20231518" class="csl-entry" role="listitem">
Wang, Xiaoqian, Rob J. Hyndman, Feng Li, et Yanfei Kang. 2023. <span>«&nbsp;Forecast combinations: An over 50-year review&nbsp;»</span>. <em>International Journal of Forecasting</em> 39 (4): 1518‑47. <a href="https://doi.org/10.1016/j.ijforecast.2022.11.005">https://doi.org/10.1016/j.ijforecast.2022.11.005</a>.
</div>
<div id="ref-dynlm" class="csl-entry" role="listitem">
Zeileis, Achim. 2019. <em><span>dynlm</span>: Dynamic Linear Regression</em>. <a href="https://CRAN.R-project.org/package=dynlm">https://CRAN.R-project.org/package=dynlm</a>.
</div>
<div id="ref-strucchangeBP" class="csl-entry" role="listitem">
Zeileis, Achim, Christian Kleiber, Walter Krämer, et Kurt Hornik. 2003. <span>«&nbsp;Testing and Dating of Structural Changes in Practice&nbsp;»</span>. <em>Computational Statistics &amp; Data Analysis</em> 44 (1–2): 109‑23. <a href="https://doi.org/10.1016/S0167-9473(03)00030-6">https://doi.org/10.1016/S0167-9473(03)00030-6</a>.
</div>
<div id="ref-abs2006" class="csl-entry" role="listitem">
Zhang, Xichuan (Mark), et Anna Poskitt. 2006. <span>«&nbsp;An ARIMA model based approach to estimate evolving trading day effect&nbsp;»</span>. <em>Presented at the Joint Statistical Meeting</em>.
</div>
</div>
</section>


<div id="quarto-appendix" class="default"><section id="installation-de-tvcoef" class="level1 appendix" data-number="6"><h2 class="anchored quarto-appendix-heading"><span class="header-section-number">6</span> Installation de <code>tvCoef</code></h2><div class="quarto-appendix-contents">

<p>Pour utiliser <code>tvCoef</code>, il faut il faut avoir la version 17 de Java SE (ou une version supérieure).</p>
<p>Pour savoir quelle version de Java est utilisée par R, utiliser le code suivant :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(rJava)</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="fu">.jinit</span>()</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a><span class="fu">.jcall</span>(<span class="st">"java/lang/System"</span>, <span class="st">"S"</span>, <span class="st">"getProperty"</span>, <span class="st">"java.runtime.version"</span>)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Si le résultat n’est pas sous la forme <code>"17xxxx"</code> c’est que vous n’avez pas Java 17 !</p>
<p>Si l’on a pas cette version d’installée et que l’on n’a pas les droits d’administrateur pour installer Java, une solution est d’installer une version portable de Java, par exemple installer une version portable à partir des liens suivants :</p>
<ul>
<li><p><a href="https://www.azul.com/downloads/#zulu">Zulu JDK</a></p></li>
<li><p><a href="https://adoptopenjdk.net/">AdoptOpenJDK</a></p></li>
<li><p><a href="https://aws.amazon.com/corretto/">Amazon Corretto</a></p></li>
</ul>
<p>Pour installer une version portable de java, télécharger par exemple le fichier <code>Windows 10 x64 Java Development Kit</code> disponible sur <a href="https://jdk.java.net/java-se-ri/17" class="uri">https://jdk.java.net/java-se-ri/17</a>, le dézipper et le mettre par exemple sous <code>""</code>.</p>
<p>Pour configurer R avec une version portable de Java, trois solutions&nbsp;:</p>
<ol type="1">
<li>Avant <strong>avant tout chargement de package nécessitant Java (<code>rJava</code>…)</strong> (si vous avez lancé le code précédent, relancez donc R) :</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Si la version portable est installée sous D:/Programmes/jdk-17</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a><span class="fu">Sys.setenv</span>(<span class="at">JAVA_HOME=</span><span class="st">'D:/Programmes/jdk-17'</span>)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ol start="2" type="1">
<li>Pour éviter de faire cette manipulation à chaque fois que l’on relance R, deux solutions&nbsp;:</li>
</ol>
<ol type="a">
<li><p>modifier le <code>JAVA_HOME</code> dans les variables d’environnement de Windows (voir <a href="https://confluence.atlassian.com/doc/setting-the-java_home-variable-in-windows-8895.html" class="uri">https://confluence.atlassian.com/doc/setting-the-java_home-variable-in-windows-8895.html</a>).</p></li>
<li><p>modifier le <code>.Renviron</code> : depuis R lancer le code <code class="sourceCode r"><span class="fu">file.edit</span>(<span class="st">"~/.Renviron"</span>)</code>, ajouter dans le fichier le chemin vers la version portable de Java comme précédemment (<code>JAVA_HOME='D:/Programmes/jdk-17'</code>), sauvegarder et relancer R.</p></li>
</ol>
<p>Il reste maintenant à installer les packages :</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Nécessaire pour installer rjd3sts</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>remotes<span class="sc">::</span><span class="fu">install_github</span>(<span class="st">"rjdemetra/rjd3toolkit"</span>)</span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Pour installer rjd3sts (modèles espace-état)</span></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>remotes<span class="sc">::</span><span class="fu">install_github</span>(<span class="st">"rjdemetra/rjd3sts"</span>)</span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>remotes<span class="sc">::</span><span class="fu">install_github</span>(<span class="st">"InseeFrLab/tvCoef"</span>)</span></code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Si vous utilisez un ordinateur professionnel, si c’est nécessaire,pensez à configurer le proxy pour que ces commandes puissent fonctionner (voir <a href="https://www.book.utilitr.org/01_r_insee/fiche-personnaliser-r#le-fichier-.renviron" class="uri">https://www.book.utilitr.org/01_r_insee/fiche-personnaliser-r#le-fichier-.renviron</a>). Pour cela vous pouvez utiliser <code>curl::ie_get_proxy_for_url()</code> pour récupérer l’adresse du proxy et ajouter deux variable <code>http_proxy</code> et <code>https_proxy</code> dans les variables d’environnement (comme précédemment).</p>
<!--  -->
</div></section><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Notes de bas de page</h2>

<ol>
<li id="fn1"><p> Cette série est disponible à l’URL <a href="https://www.insee.fr/fr/statistiques/serie/001565530" class="uri">https://www.insee.fr/fr/statistiques/serie/001565530</a>.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p> Voir par exemple <span class="citation" data-cites="hansen1992I1">Hansen (<a href="#ref-hansen1992I1" role="doc-biblioref">1992b</a>)</span>. Une implémentation sous <i class="fa-brands fa-r-project" aria-label="r-project"></i> de ce cas est disponible sous <a href="https://users.ssc.wisc.edu/~bhansen/progs/jbes_92.html" class="uri">https://users.ssc.wisc.edu/~bhansen/progs/jbes_92.html</a>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p> D’autres packages sont disponibles pour effectuer de la régression locale, dont par exemple <code>locfit</code> de <span class="citation" data-cites="locfit">Catherine Loader (<a href="#ref-locfit" role="doc-biblioref">2023</a>)</span>. Toutefois, nous avons ici privilégié le package <code>tvReg</code> du fait de sa simplicité d’utilisation et parce qu’il implémente également une fonction <code>tvReg::tvAR()</code> pour permet de prendre en compte de manière optimale les retards de la variable endogène (non étudiée dans cette étude).<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p> Ce qui aurait pu être le cas si le modèle avait été estimé en utilisant le paramètre <code>formula = growth_gdp ~ bc_fr_m1 + diff(bc_fr_m1, 1)</code> dans la fonction <code>dynlm()</code>.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section><section class="quarto-appendix-contents" id="quarto-citation"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@article{quartier-la-tente2024,
  author = {Quartier-la-Tente, Alain},
  title = {Utilisation de modèles de régression à coefficients variant
    dans le temps pour la prévision conjoncturelle},
  journal = {Document de travail méthodologique Insee},
  date = {2024},
  url = {https://github.com/InseeFrLab/DT-tvcoef},
  langid = {fr}
}
</code><button title="Copier vers le presse-papier" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">Veuillez citer ce travail comme suit&nbsp;:</div><div id="ref-quartier-la-tente2024" class="csl-entry quarto-appendix-citeas" role="listitem">
Quartier-la-Tente, Alain. 2024. <span>“Utilisation de modèles de
régression à coefficients variant dans le temps pour la prévision
conjoncturelle.”</span> <em>Document de travail méthodologique
Insee</em>. <a href="https://github.com/InseeFrLab/DT-tvcoef">https://github.com/InseeFrLab/DT-tvcoef</a>.
</div></div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copié");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copié");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>